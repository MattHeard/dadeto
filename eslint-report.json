[{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/eslint.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/generate.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/jest.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/src/generator/full-width.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/src/generator/generator.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/src/generator/head.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/src/generator/html.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/src/generator/interactive.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/src/generator/main.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/src/generator/script.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/src/generator/styles.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/src/generator/title.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/src/toys/2024-10-02/hello.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/src/toys/2025-03-19/identity.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/src/toys/2025-03-21/booleanCoercer.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/src/toys/2025-03-21/italics.js","messages":[{"ruleId":"complexity","severity":1,"message":"Function 'processTextPreservingBold' has a complexity of 6. Maximum allowed is 5.","line":90,"column":1,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":111,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Markdown marker characters\nconst ASTERISK_MARKER = '*';\nconst UNDERSCORE_MARKER = '_';\n\n// Pattern to match special regex characters that need escaping\nconst REGEX_SPECIAL_CHARS = /[.*+?^${}()|[\\]\\\\]/;\n\n/**\n * Creates a doubled marker (e.g., ** or __) for bold text\n * @param {string} marker - The marker character (* or _)\n * @returns {string} - The doubled marker\n * @private\n */\nfunction createDoubledMarker(marker) {\n  return marker.repeat(2);\n}\n\n/**\n * Creates a regex pattern part for bold text with a specific marker\n * @param {string} marker - The marker character (* or _)\n * @returns {string} - Regex pattern string for bold with the specified marker\n * @private\n */\nfunction createBoldPatternPart(marker) {\n  // Escape marker if it's a special regex character\n  const escapedMarker = REGEX_SPECIAL_CHARS.test(marker) ? `\\\\${marker}` : marker;\n  const doubledMarker = createDoubledMarker(escapedMarker);\n  \n  // Break the pattern into its constituent parts\n  const patternParts = [\n    '(?:', // Opening non-capturing group\n    doubledMarker, // Opening doubled marker\n    '.*?', // Lazy match of content\n    doubledMarker, // Closing doubled marker\n    ')' // Closing group\n  ];\n  \n  return patternParts.join('');\n}\n\n/**\n * Returns a regex pattern that matches both asterisk and underscore bold markdown\n * @returns {RegExp} - The regex pattern for bold markdown\n * @private\n */\nfunction createBoldPattern() {\n  const boldMarkers = [ASTERISK_MARKER, UNDERSCORE_MARKER];\n  const patternParts = boldMarkers.map(createBoldPatternPart);\n  \n  // Combine with OR operator for alternative matching\n  const pattern = patternParts.join('|');\n  \n  return new RegExp(pattern, 's');\n}\n\n/**\n * Returns a regex pattern that matches text wrapped with a specific marker\n * @param {string} marker - The marker character (* or _)\n * @returns {RegExp} - The regex pattern for the specified marker\n * @private\n */\nfunction createItalicsPattern(marker) {\n  // Escape marker if it's a special regex character\n  const escapedMarker = REGEX_SPECIAL_CHARS.test(marker) ? `\\\\${marker}` : marker;\n  return new RegExp(`${escapedMarker}(.*?)${escapedMarker}`, 'g');\n}\n\n/**\n * Returns the array of markers used for italic styles\n * @returns {Array} - Array of marker characters\n * @private\n */\nfunction getItalicMarkers() {\n  return [ASTERISK_MARKER, UNDERSCORE_MARKER];\n}\n\n/**\n * Process text recursively to handle all formatting cases, preserving bold segments.\n * This function identifies bold markdown segments and leaves them unmodified,\n * while processing the text before and after for italic formatting.\n * \n * @example\n * // Returns: '**bold** <em>*italic*</em>'\n * processTextPreservingBold('**bold** *italic*');\n * \n * @param {string} text - The text to process\n * @returns {string} - Processed text with HTML tags added around italics while preserving bold\n * @private\n */\nfunction processTextPreservingBold(text) {\n  // For recursive calls with empty segments, return early\n  if (!text || text.trim() === '') {\n    return '';\n  }\n  \n  // First, identify any bold patterns\n  const boldSegments = findBoldSegments(text);\n  \n  if (!boldSegments) {\n    // No bold pattern found, process italics only\n    return processAllItalicStyles(text);\n  }\n  \n  // Extract the segments and immediately process them for the return value\n  const { boldText, beforeText, afterText } = boldSegments;\n  \n  // Combine the processed sections with the unchanged bold text in a single return statement\n  return (beforeText ? processAllItalicStyles(beforeText) : '') + \n         boldText + \n         (afterText ? processTextPreservingBold(afterText) : '');\n}\n\n// Main exported function\n\n/**\n * Adds HTML <em> tags around text marked with Markdown italics while preserving\n * the original Markdown characters.\n * \n * Handles both *single asterisk* and _underscore_ style Markdown italics.\n * Does NOT add <em> tags around bold markdown syntax (** or __).\n * \n * @example\n * // Returns: '<em>*italic*</em> text'\n * italics('*italic* text');\n * \n * @example\n * // Returns: '<em>_italic_</em> text'\n * italics('_italic_ text');\n * \n * @example\n * // Returns: '**bold** and <em>*italic*</em>'\n * italics('**bold** and *italic*');\n * \n * @param {string} text - The input text that may contain Markdown italics syntax\n * @returns {string} Text with HTML <em> tags added around Markdown-formatted italics\n */\nexport function italics(text) {\n  if (!text || typeof text !== 'string') {\n    return text;\n  }\n  \n  // We'll use a recursive approach with special handling for bold segments\n  return processTextPreservingBold(text);\n}\n\n// Helper functions for processing text\n\n/**\n * Find bold segments in text and split into bold text and surrounding text\n * \n * @param {string} text - The text to process\n * @returns {Object|null} - Object with boldText, beforeText, and afterText properties, or null if no bold found\n * @private\n */\nfunction findBoldSegments(text) {\n  const boldMatch = text.match(createBoldPattern());\n  \n  if (!boldMatch) {\n    return null;\n  }\n  \n  const boldText = boldMatch[0];\n  const boldStartIndex = boldMatch.index;\n  const boldEndIndex = boldStartIndex + boldText.length;\n  \n  return {\n    boldText,\n    beforeText: text.substring(0, boldStartIndex),\n    afterText: text.substring(boldEndIndex)\n  };\n}\n\n/**\n * Apply italic formatting for a specific marker to the text\n * @param {string} text - The text to process\n * @param {string} marker - The marker character (* or _)\n * @returns {string} - Text with the particular italic style formatted\n * @private\n */\nfunction applyItalicFormatting(text, marker) {\n  const pattern = createItalicsPattern(marker);\n  return text.replace(pattern, (match, capturedContent) => {\n    return createItalicReplacementString(capturedContent, marker);\n  });\n}\n\n/**\n * Process text through all italic style types (asterisk and underscore)\n * \n * @example\n * // Returns: '<em>*text*</em>'\n * processAllItalicStyles('*text*');\n * \n * @example\n * // Returns: '<em>_text_</em>'\n * processAllItalicStyles('_text_');\n * \n * @param {string} text - The text to process \n * @returns {string} - Text with all italic styles formatted\n * @private\n */\nfunction processAllItalicStyles(text) {\n  // Process the text through all italic markers using reduce\n  return getItalicMarkers().reduce(applyItalicFormatting, text);\n}\n\n/**\n * Wrap content with a marker at the beginning and end\n * @param {string} content - The content to wrap\n * @param {string} marker - The marker to add at beginning and end\n * @returns {string} - Content wrapped with markers\n * @private\n */\nfunction wrapWithMarker(content, marker) {\n  return `${marker}${content}${marker}`;\n}\n\n/**\n * Create an HTML tag wrapper for content\n * @param {string} tagName - The HTML tag name (without brackets)\n * @param {string} content - The content to wrap\n * @returns {string} - The content wrapped in the HTML tag\n * @private\n */\nfunction wrapWithHtmlTag(tagName, content) {\n  return [`<${tagName}>`, content, `</${tagName}>`].join('');\n}\n\n/**\n * Create a replacement string for italic markdown content\n * @param {string} content - The inner content of the markdown\n * @param {string} marker - The markdown marker character (* or _)\n * @returns {string} - HTML formatted replacement string\n * @private\n */\nfunction createItalicReplacementString(content, marker) {\n  // First wrap content with markdown markers, then with HTML tag\n  return wrapWithHtmlTag('em', wrapWithMarker(content, marker));\n}\n\n\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/test/generator/generator.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/test/toys/2024-10-02/hello.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/test/toys/2025-03-19/identity.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/test/toys/2025-03-21/booleanCoercer.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/test/toys/2025-03-21/italics.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]