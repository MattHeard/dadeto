[{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/eslint.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/generate.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/jest.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/src/generator/full-width.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/src/generator/generator.js","messages":[{"ruleId":"complexity","severity":1,"message":"Function 'renderValueDiv' has a complexity of 4. Maximum allowed is 3.","line":405,"column":1,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":417,"endColumn":2},{"ruleId":"complexity","severity":1,"message":"Function 'generateMediaContent' has a complexity of 4. Maximum allowed is 3.","line":570,"column":1,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":581,"endColumn":2},{"ruleId":"complexity","severity":1,"message":"Function 'escapeRelatedLinkFields' has a complexity of 4. Maximum allowed is 3.","line":683,"column":1,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":692,"endColumn":2},{"ruleId":"complexity","severity":1,"message":"Function 'formatBaseLink' has a complexity of 5. Maximum allowed is 3.","line":694,"column":1,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":702,"endColumn":2},{"ruleId":"complexity","severity":1,"message":"Function 'composeLinkParts' has a complexity of 4. Maximum allowed is 3.","line":704,"column":1,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":709,"endColumn":2},{"ruleId":"complexity","severity":1,"message":"Function 'hasToy' has a complexity of 4. Maximum allowed is 3.","line":748,"column":1,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":750,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Create paragraphs HTML string.\n * @param {string|string[]} content - A string or an array of strings.\n * @returns {string} - HTML string composed of paragraph elements.\n */\nfunction createParagraphs(content) {\n  if (Array.isArray(content)) {\n    return content.map(para => `<p>${para}</p>`).join('');\n  } else {\n    return `<p>${content}</p>`;\n  }\n}\n\n/**\n * Create a blockquote HTML string.\n * @param {string|string[]} content - A string or an array of strings.\n * @returns {string} - The blockquote HTML.\n */\nfunction createBlockquote(content) {\n  const paragraphs = createParagraphs(content);\n  return `<blockquote class=\"${CLASS.VALUE}\">${BLOCKQUOTE_CORNERS}${paragraphs}</blockquote>`;\n}\nimport { headElement } from './head.js';\nimport { fullWidthElement } from './full-width.js';\nimport scriptTag from './script.js';\nimport { HEADER_BANNER } from './title.js';\nimport {\n  createTag,\n  createAttrPair,\n  escapeHtml,\n  wrapHtml,\n  join,\n  ATTR_NAME,\n} from './html.js';\n\n// CSS class names\nconst CLASS = {\n  KEY: 'key',\n  VALUE: 'value',\n  ENTRY: 'entry',\n  ARTICLE_TITLE: 'article-title',\n  METADATA: 'metadata',\n  FOOTER: 'footer',\n  WARNING: 'warning',\n  MEDIA: 'media',\n  FULL_WIDTH: 'full-width',\n};\n\nconst BLOCKQUOTE_CORNERS = `<div class=\"corner corner-tl\"><div class=\"h-line\"></div><div class=\"v-line\"></div></div><div class=\"corner corner-tr\"><div class=\"h-line\"></div><div class=\"v-line\"></div></div><div class=\"corner corner-bl\"><div class=\"h-line\"></div><div class=\"v-line\"></div></div><div class=\"corner corner-br\"><div class=\"h-line\"></div><div class=\"v-line\"></div></div>`;\n\n// HTML tag names\nconst DIV_TAG_NAME = 'div';\nconst ARTICLE_TAG_NAME = 'article';\n\n// Date formatting constants\nconst DATE_LOCALE = 'en-GB';\nconst DATE_FORMAT_OPTIONS = {\n  day: 'numeric',\n  month: 'short',\n  year: 'numeric',\n};\n\n// Container ID\nconst CONTAINER_ID = 'container';\n\n// HTML generation helpers\n\n/**\n * Create a div element with specified classes and content\n * @param {string} classes - CSS classes to apply to the div\n * @param {string} content - HTML content to place inside the div\n * @returns {string} - HTML div element\n */\nfunction createDiv(classes, content) {\n  const classAttr = createAttrPair(ATTR_NAME.CLASS, classes);\n  return createTag(DIV_TAG_NAME, classAttr, content);\n}\n\n/**\n * Join CSS classes into a space-separated string\n * @param {string[]} classes - Array of CSS class names\n * @returns {string} - Space-separated class string\n */\nfunction joinClasses(classes) {\n  return classes.join(' ');\n}\n\n/**\n * Create a div with the value class and optional additional classes\n * @param {string} content - Content for the value div\n * @param {string[]} additionalClasses - Additional CSS classes to apply\n * @returns {string} - HTML div element with value class and any additional classes\n */\nfunction createValueDiv(content, additionalClasses = []) {\n  const classes = [CLASS.VALUE, ...additionalClasses].filter(Boolean);\n  const joinedClasses = joinClasses(classes);\n  return createDiv(joinedClasses, content);\n}\n\n/**\n * Create an array with two parts for joining\n * @param {string} first - The first part\n * @param {string} second - The second part\n * @returns {Array<string>} - Array containing both parts\n */\nfunction createParts(first, second) {\n  return [first, second];\n}\n\n/**\n * Create a pair with two elements\n * @param {string} first - The first element\n * @param {string} second - The second element\n * @returns {string} - Combined HTML without newlines\n */\nfunction createPair(first, second) {\n  const parts = createParts(first, second);\n  return join(parts);\n}\n\n/**\n * Convert a date string to a Date object\n * @param {string} dateString - The date string to convert\n * @returns {Date} - The Date object\n */\nfunction createDateFromString(dateString) {\n  return new Date(dateString);\n}\n\n/**\n * Format a date using the locale and options\n * @param {Date} date - The date to format\n * @returns {string} - The formatted date string\n */\nfunction formatDateWithOptions(date) {\n  return date.toLocaleDateString(DATE_LOCALE, DATE_FORMAT_OPTIONS);\n}\n\n/**\n * Format date in \"4 May 2022\" format\n * @param {string} dateString - The date string to format\n * @returns {string} - The formatted date string\n */\nfunction formatDate(dateString) {\n  const date = createDateFromString(dateString);\n  return formatDateWithOptions(date);\n}\n\n// Header components\n\n// No longer using newlines and indentation\n\nconst METADATA_TEXT = `Software developer and philosopher in Berlin`;\n\n/**\n * Create an empty div with the key class\n * @returns {string} - HTML div element with key class and no content\n */\nfunction createEmptyKeyDiv() {\n  return createDiv(CLASS.KEY, '');\n}\n\nfunction prefixWithEmptyKey(valueDiv) {\n  const emptyKeyDiv = createEmptyKeyDiv();\n  return createPair(emptyKeyDiv, valueDiv);\n}\n\n/**\n * Create the content for the header section\n */\nfunction createHeaderContent() {\n  const valueDivs = [\n    createValueDiv(HEADER_BANNER),\n    createValueDiv(METADATA_TEXT, [CLASS.METADATA])\n  ];\n\n  const parts = valueDivs.map(prefixWithEmptyKey);\n  \n  return join(parts);\n}\n\n/**\n * Create a section with the given content\n * @param {string} content - The content to wrap in a section\n * @returns {string} - HTML for the section\n */\nfunction createSection(content) {\n  return createDiv(CLASS.ENTRY, content);\n}\n\n/**\n * Create the header section with banner and metadata\n * @returns {string} - HTML for the header section\n */\nfunction createHeaderSection() {\n  const headerContent = createHeaderContent();\n  return createSection(headerContent);\n}\n\n// Footer components\nconst WARNING_MESSAGE =\n  'All content is authored by Matt Heard and is <a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\">CC BY-NC-SA 4.0</a>, unless otherwise noted.';\n\n/**\n * Create the content for the footer section\n * @returns {string} - HTML for the footer content\n */\nfunction createFooterContent() {\n  const classes = joinClasses([CLASS.FOOTER, CLASS.VALUE, CLASS.WARNING]);\n  const footerDiv = createDiv(classes, WARNING_MESSAGE);\n  return prefixWithEmptyKey(footerDiv);\n}\n\n/**\n * Create the footer section with warning message\n * @returns {string} - HTML for the footer section\n */\nfunction createFooterSection() {\n  const footerContent = createFooterContent();\n  return createSection(footerContent);\n}\n\n// Page structure\n/**\n * Create the opening tag for the container div\n * @returns {string} - Opening div tag with container ID\n */\nfunction createContainerDivOpen() {\n  const idAttr = createAttrPair(ATTR_NAME.ID, CONTAINER_ID);\n  return `<${DIV_TAG_NAME} ${idAttr}>`;\n}\n\n/**\n * Create the header content array\n */\nfunction createHeaderContentArray(headerElement) {\n  return [\n    headElement,\n    '<body>',\n    createContainerDivOpen(),\n    '<!-- Header -->',\n    headerElement,\n  ];\n}\n\n/**\n * Create the page header with head element, body opening tag and header section\n */\nfunction createPageHeader() {\n  const headerElement = createHeaderSection();\n  const contentArray = createHeaderContentArray(headerElement);\n\n  return contentArray.join('');\n}\n\n/**\n * Create the closing container div\n */\nfunction createContainerDivClose() {\n  return '</div>';\n}\n\n/**\n * Create the body closing tag\n */\nfunction createBodyClose() {\n  return '</body>';\n}\n\n/**\n * Create the footer content array\n */\nfunction createFooterContentArray(footerElement) {\n  return [\n    '',\n    footerElement,\n    createContainerDivClose(),\n    scriptTag,\n    createBodyClose(),\n  ];\n}\n\n/**\n * Create the page footer with footer section, container div closing, and body closing tag\n */\nfunction createPageFooter() {\n  const footerElement = createFooterSection();\n  const contentArray = createFooterContentArray(footerElement);\n\n  return contentArray.join('');\n}\n\n/**\n * Convert a post to article HTML\n */\nfunction convertPostToArticleHTML(post) {\n  return generateArticle(post);\n}\n\n/**\n * Format article HTML with indentation\n */\nfunction formatArticleHTML(articleHTML) {\n  return articleHTML;\n}\n\n/**\n * Process posts and join article HTML\n */\nfunction processPostsToHTML(posts) {\n  return posts.map(convertPostToArticleHTML)\n              .map(formatArticleHTML)\n              .join('');\n}\n\n/**\n * Generate HTML for all articles in the blog\n */\nfunction generateArticles(posts) {\n  return processPostsToHTML(posts);\n}\n\n/**\n * Create attributes for an article element\n */\nfunction createIdAttributeIfNeeded(post) {\n  if (!post.key) {\n    return '';\n  }\n\n  return ' ' + createAttrPair(ATTR_NAME.ID, post.key);\n}\n\n/**\n * Create attributes for an article element\n */\nfunction createArticleAttributes(post) {\n  const tagClasses = hasTags(post) ? post.tags.map(tag => `tag-${tag}`).join(' ') : '';\n  const classValue = tagClasses ? `${CLASS.ENTRY} ${tagClasses}` : CLASS.ENTRY;\n  const classAttr = createAttrPair(ATTR_NAME.CLASS, classValue);\n  const idAttr = createIdAttributeIfNeeded(post);\n  return `${classAttr}${idAttr}`;\n}\n\n/**\n * Format article content with full width element\n */\nfunction formatArticleContent(content) {\n  return `${fullWidthElement}${content}`;\n}\n\n/**\n * Create an article from a blog post\n */\nfunction generateArticle(post) {\n  const content = generateArticleContent(post);\n  const formattedContent = formatArticleContent(content);\n  const attributes = createArticleAttributes(post);\n\n  return createTag(ARTICLE_TAG_NAME, attributes, formattedContent);\n}\n\n/**\n * Get content array from post, defaulting to empty array if not present\n */\nfunction getContentArray(post) {\n  return post.content || [];\n}\n\n/**\n * Determine if an item is the first in the content array\n */\nfunction isFirstContentItem(index) {\n  return index === 0;\n}\n\n/**\n * Create a content item with index awareness\n */\nfunction createContentItemWithIndex(text, index) {\n  const isFirst = isFirstContentItem(index);\n  return createContentSectionItem(text, isFirst);\n}\n\n/**\n * Normalize a content item.\n * If content is already an object, return it unchanged;\n * otherwise, wrap it in an object with type 'text' and content fields.\n * @param {Object|string} content - The content item to normalize.\n * @returns {Object} - Normalized content object.\n */\nfunction normalizeContentItem(content) {\n  return (typeof content === 'object' && content !== null)\n    ? content\n    : { type: 'text', content: content };\n}\n\n/**\n * Mapping of content types to their renderer functions.\n */\nconst CONTENT_RENDERERS = {\n  quote: createBlockquote,\n};\n\nfunction renderValueDiv(normalizedContent) {\n  const { type, content } = normalizedContent;\n \n  if (type === 'quote') {\n    return CONTENT_RENDERERS.quote(content);\n  }\n \n  if (type === 'text' && Array.isArray(content)) {\n    return createBlockquote(content);\n  }\n \n  return `<p class=\"${CLASS.VALUE}\">${content}</p>`;\n}\n\n/**\n * Create a content section item with exact formatting\n * @param {Object|string} content - The content object or text\n * @param {boolean} isFirst - Whether this is the first content item\n * @returns {string} - Formatted content section HTML\n */\nfunction createContentSectionItem(content, isFirst) {\n  const normalizedContent = normalizeContentItem(content);\n  const key = isFirst ? 'text' : '';\n  const keyDiv = createDiv(CLASS.KEY, key);\n  const valueDiv = renderValueDiv(normalizedContent);\n \n  return formatSection(keyDiv, valueDiv);\n}\n\n/**\n * Generate the text content sections for a blog post\n */\nfunction generateContentSections(post) {\n  const contentArray = getContentArray(post);\n\n  const contentItems = contentArray.map(createContentItemWithIndex);\n\n  return combineHTMLSections(...contentItems);\n}\n\n/**\n * Generate header section for a blog post\n */\nfunction generateHeaderSection(post) {\n  const titleSection = generateTitleSection(post);\n  const dateSection = generateDateSection(post);\n  const tagsSection = generateTagsSection(post);\n\n  return combineHTMLSections(titleSection, dateSection, tagsSection);\n}\n\n/**\n * Create the title value for a blog post\n */\nfunction createTitleValue(post) {\n  const titleLink = `<a href=\"#${post.key}\">${post.title}</a>`;\n  const titleHeader = `<h2>${titleLink}</h2>`;\n  return `<div class=\"${CLASS.VALUE}\">${titleHeader}</div>`;\n}\n\n/**\n * Generate the title section for a blog post\n */\nfunction generateTitleSection(post) {\n  const titleClasses = joinClasses([CLASS.KEY, CLASS.ARTICLE_TITLE]);\n  const titleKey = createDiv(titleClasses, post.key);\n  const titleValue = createTitleValue(post);\n\n  return createPair(titleKey, titleValue);\n}\n\n/**\n * Generate the date section for a blog post\n */\nfunction generateDateSection(post) {\n  if (!post.publicationDate) {\n    return '';\n  }\n\n  const dateKey = createDiv(CLASS.KEY, 'pubAt');\n  const dateValue = `<p class=\"${CLASS.VALUE} ${CLASS.METADATA}\">${formatDate(post.publicationDate)}</p>`;\n\n  return createPair(dateKey, dateValue);\n}\n\n/**\n * Generate the tags section for a blog post\n * @param {Object} post - The blog post\n * @returns {string} - HTML for the tags section\n */\nfunction generateTagsSection(post) {\n  if (!hasTags(post)) {\n    return '';\n  }\n\n  const tagsKey = createDiv(CLASS.KEY, 'tags');\n  const tagsContent = post.tags.map(tag => {\n    const escapedTag = escapeHtml(tag);\n    return `<a class=\"tag-${escapedTag}\">${escapedTag}</a>`;\n  }).join(', ');\n  const tagsValue = `<p class=\"${CLASS.VALUE} ${CLASS.METADATA}\">${tagsContent}</p>`;\n\n  return createPair(tagsKey, tagsValue);\n}\n\n/**\n * Check if post has the specified media type\n */\nfunction hasMediaType(post, mediaType) {\n  return !!post[mediaType];\n}\n\n/**\n * Check if post has related links\n * @param {Object} post - The blog post\n * @returns {boolean} - True if post has related links\n */\nfunction hasRelatedLinks(post) {\n  return post.relatedLinks !== undefined && Array.isArray(post.relatedLinks) && post.relatedLinks.length > 0;\n}\n\n/**\n * Check if post has tags\n * @param {Object} post - The blog post\n * @returns {boolean} - True if post has tags\n */\nfunction hasTags(post) {\n  return post.tags !== undefined && Array.isArray(post.tags) && post.tags.length > 0;\n}\n\n/**\n * Check if post either is YouTube content or has a publication date\n */\nfunction isValidMediaType(post, mediaType) {\n  return mediaType === 'youtube' || post.publicationDate;\n}\n\n/**\n * Check if media should be displayed\n */\nfunction shouldDisplayMedia(post, mediaType) {\n  return hasMediaType(post, mediaType) && isValidMediaType(post, mediaType);\n}\n\n/**\n * Create a key div for media sections\n */\nfunction createMediaKeyDiv(label) {\n  const classes = `${CLASS.KEY} ${CLASS.MEDIA}`;\n  return createDiv(classes, label);\n}\n\n/**\n * Format a section with key and value divs\n * @param {string} keyDiv - The key div HTML\n * @param {string} valueDiv - The value div HTML\n * @returns {string} - Formatted section HTML\n */\nfunction formatSection(keyDiv, valueDiv) {\n  return `${keyDiv}${valueDiv}`;\n}\n\n/**\n * Generate media content based on media type\n */\nfunction generateMediaContent(post, mediaType) {\n  switch (mediaType) {\n    case 'illustration':\n      return createIllustrationContent(post);\n    case 'audio':\n      return createAudioContent(post);\n    case 'youtube':\n      return createYouTubeContent(post);\n    default:\n      return '';\n  }\n}\n\n/**\n * Higher-order function for generating media sections\n */\nfunction createMediaSectionGenerator(mediaType, label) {\n  return function (post) {\n    if (!shouldDisplayMedia(post, mediaType)) {\n      return '';\n    }\n\n    const keyDiv = createMediaKeyDiv(label);\n    const valueDiv = generateMediaContent(post, mediaType);\n\n    return formatSection(keyDiv, valueDiv);\n  };\n}\n\n/**\n * Create illustration image element\n */\nfunction createIllustrationImage(post) {\n  // Use fileName if provided, otherwise fall back to publicationDate\n  const fileName = post.illustration.fileName || post.publicationDate;\n  const src = `${fileName}.${post.illustration.fileType}`;\n  const altText = post.illustration.altText;\n\n  return `<img loading=\"lazy\" src=\"${src}\" alt=\"${altText}\"/>`;\n}\n\n/**\n * Create illustration content\n */\nfunction createIllustrationContent(post) {\n  const image = createIllustrationImage(post);\n\n  return `<div class=\"${CLASS.VALUE}\">${image}</div>`;\n}\n\n/**\n * Create audio source element\n */\nfunction createAudioSource(post) {\n  const audioSrc = `${post.publicationDate}.${post.audio.fileType}`;\n  return `<source src=\"${audioSrc}\">`;\n}\n\n/**\n * Create audio content\n */\nfunction createAudioContent(post) {\n  const source = createAudioSource(post);\n\n  return `<audio class=\"${CLASS.VALUE}\" controls>${source}</audio>`;\n}\n\n/**\n * Create YouTube iframe with proper attributes\n */\nfunction createYouTubeIframe(post) {\n  const youtubeId = post.youtube.id;\n  const timestamp = post.youtube.timestamp;\n  const title = escapeHtml(post.youtube.title);\n\n  return `<iframe height=\"300px\" width=\"100%\" src=\"https://www.youtube.com/embed/${youtubeId}?start=${timestamp}\" title=\"${title}\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" loading=\"lazy\" allowfullscreen></iframe>`;\n}\n\n/**\n * Create YouTube content\n */\nfunction createYouTubeContent(post) {\n  const iframe = createYouTubeIframe(post);\n\n  return `<p class=\"${CLASS.VALUE}\">${iframe}</p>`;\n}\n\n\n/**\n * Mapping for media sections.\n * Each key maps to a function that generates the corresponding media section.\n */\nconst MEDIA_SECTIONS = {\n  illustration: createMediaSectionGenerator('illustration', 'illus'),\n  audio: createMediaSectionGenerator('audio', 'audio'),\n  youtube: createMediaSectionGenerator('youtube', 'video'),\n};\n\n/**\n * Generate all media sections for a blog post by iterating over the MEDIA_SECTIONS mapping.\n */\nfunction generateMediaSections(post) {\n  const sections = Object.values(MEDIA_SECTIONS).map(generator => generator(post));\n  return combineHTMLSections(...sections);\n}\n\n/**\n * Format a related link to display in the list\n * @param {Object} link - The related link object\n * @returns {string} - Formatted HTML for a related link\n */\nconst DEFAULT_RELATED_LINK_ATTRS = 'target=\"_blank\" rel=\"noopener\"';\n\nfunction escapeRelatedLinkFields(link) {\n  return {\n    url: escapeHtml(link.url),\n    title: escapeHtml(link.title),\n    author: link.author ? escapeHtml(link.author) : '',\n    source: link.source ? escapeHtml(link.source) : '',\n    quote: link.quote ? escapeHtml(link.quote) : '',\n    type: link.type,\n  };\n}\n\nfunction formatBaseLink(type, url, title) {\n  const formattedTitle = (type === 'book')\n    ? `<em>_${title}_</em>`\n    : (type === 'microblog' || type === 'article' || type === 'report')\n    ? `\"${title}\"`\n    : title;\n\n  return `<a href=\"${url}\" ${DEFAULT_RELATED_LINK_ATTRS}>${formattedTitle}</a>`;\n}\n\nfunction composeLinkParts(baseLink, author, source, quote) {\n  const authorPart = author ? ` by ${author}` : '';\n  const sourcePart = source ? `, ${source}` : '';\n  const quotePart = quote ? ` (\"${quote}\")` : '';\n  return `<li>${baseLink + authorPart + sourcePart + quotePart}</li>`;\n}\n\nfunction formatRelatedLink(link) {\n  const { url, title, author, source, quote, type } = escapeRelatedLinkFields(link);\n  const baseLink = formatBaseLink(type, url, title);\n  return composeLinkParts(baseLink, author, source, quote);\n}\n\n/**\n * Generate the related links section for a blog post\n * @param {Object} post - The blog post\n * @returns {string} - HTML for the related links section\n */\nfunction generateRelatedLinksSection(post) {\n  if (!hasRelatedLinks(post)) {\n    return '';\n  }\n\n  const keyDiv = createDiv(CLASS.KEY, 'links');\n  // Join with an empty string to avoid spacing issues in the HTML output\n  const linksList = post.relatedLinks.map(link => formatRelatedLink(link)).join('');\n  const valueContent = `<ul class=\"related-links\">${linksList}</ul>`;\n  const valueDiv = createDiv(CLASS.VALUE, valueContent);\n\n  return formatSection(keyDiv, valueDiv);\n}\n\n/**\n * Combine multiple HTML sections into a single string\n */\nfunction combineHTMLSections(...sections) {\n  return sections.join('');\n}\n\n/**\n * Check if post has a toy component\n * @param {Object} post - The blog post\n * @returns {boolean} - True if post has a toy component\n */\nfunction hasToy(post) {\n  return post && post.toy && post.toy.modulePath && post.toy.functionName;\n}\n\n/**\n * Generate the input section for a toy component\n * @returns {string} - HTML for the input section\n */\nfunction generateToyInputSection() {\n  const keyDiv = createDiv(CLASS.KEY, 'in');\n  const valueContent = '<form><input type=\"text\" disabled></form>';\n  const valueDiv = createValueDiv(valueContent);\n  \n  return formatSection(keyDiv, valueDiv);\n}\n\n/**\n * Generate the button section for a toy component\n * @returns {string} - HTML for the button section\n */\nfunction generateToyButtonSection() {\n  const keyDiv = createEmptyKeyDiv();\n  const valueContent = '<button type=\"submit\" disabled>Submit</button>';\n  const valueDiv = createValueDiv(valueContent);\n  \n  return formatSection(keyDiv, valueDiv);\n}\n\n/**\n * Generate the output section for a toy component\n * @returns {string} - HTML for the output section\n */\nfunction generateToyOutputSection() {\n  const keyDiv = createDiv(CLASS.KEY, 'out');\n  const valueContent = '<p class=\"output\">This toy requires Javascript to run.</p>';\n  const valueDiv = createValueDiv(valueContent, [CLASS.WARNING]);\n  \n  return formatSection(keyDiv, valueDiv);\n}\n\n/**\n * Generate script tag to add the component\n * @param {Object} post - The blog post\n * @returns {string} - HTML script tag\n */\nfunction generateToyScript(post) {\n  const scriptContent = `window.addComponent('${post.key}', '${post.toy.modulePath}', '${post.toy.functionName}');`;\n  return `<script type=\"module\">${scriptContent}</script>`;\n}\n\n/**\n * Generate the toy UI components for a blog post\n * @param {Object} post - The blog post\n * @returns {string} - HTML for the toy UI components\n */\nfunction generateToyUISection(post) {\n  if (!hasToy(post)) {\n    return '';\n  }\n  \n  return combineHTMLSections(\n    generateToyInputSection(),\n    generateToyButtonSection(),\n    generateToyOutputSection()\n  );\n}\n\n/**\n * Generate the toy script section for a blog post\n * @param {Object} post - The blog post\n * @returns {string} - HTML for the toy script section\n */\nfunction generateToyScriptSection(post) {\n  if (!hasToy(post)) {\n    return '';\n  }\n  \n  return generateToyScript(post);\n}\n\n/**\n * Get all sections for a blog post article.\n * @param {Object} post - The blog post.\n * @returns {string[]} - An array of HTML sections.\n */\nfunction getArticleSections(post) {\n  const headerSection = generateHeaderSection(post);\n  const mediaSection = generateMediaSections(post);\n  const contentSection = generateContentSections(post);\n  const toyUISection = generateToyUISection(post);\n  const relatedLinksSection = generateRelatedLinksSection(post);\n  const toyScriptSection = generateToyScriptSection(post);\n \n  return [\n    headerSection,\n    mediaSection,\n    contentSection,\n    toyUISection,\n    relatedLinksSection,\n    toyScriptSection\n  ];\n}\n\n/**\n * Generate the content of a blog post article\n */\nfunction generateArticleContent(post) {\n  return combineHTMLSections(...getArticleSections(post));\n}\n\n/**\n * Create blog HTML content array\n */\nfunction createBlogContentArray(header, articles, footer) {\n  // Remove the newline character between elements\n  return [header, articles, footer];\n}\n\n/**\n * Build the complete HTML content for the blog from header, articles, and footer.\n * @param {string} header - The header HTML.\n * @param {string} articles - The articles HTML.\n * @param {string} footer - The footer HTML.\n * @returns {string} - Combined HTML content.\n */\nfunction getBlogHtmlContent(header, articles, footer) {\n  const contentArray = createBlogContentArray(header, articles, footer);\n  return contentArray.join('');\n}\n\n/**\n * Retrieve the HTML for all articles from the blog.\n * @param {Object} blog - The blog object.\n * @returns {string} - Combined HTML for all articles.\n */\nfunction getArticles(blog) {\n  return generateArticles(blog.posts);\n}\n\n/**\n * Assemble the blog HTML content by combining header, articles, and footer.\n * @param {string} header - The header HTML.\n * @param {Object} blog - The blog object.\n * @param {string} footer - The footer HTML.\n * @returns {string} - The combined HTML content.\n */\nfunction assembleBlogHTML(header, blog, footer) {\n  const articles = getArticles(blog);\n  return getBlogHtmlContent(header, articles, footer);\n}\n\nexport function generateBlog(blog, header, footer, wrapHtml) {\n  const htmlContents = assembleBlogHTML(header, blog, footer);\n  return wrapHtml(htmlContents);\n}\n\nconst createBlogComponents = () => ({\n  header: createPageHeader(),\n  footer: createPageFooter(),\n  wrapFunc: wrapHtml,\n});\n\n/**\n * Extracts the blog generation arguments from the blog components.\n * @returns {Object} - An object containing header, footer, and wrapFunc.\n */\nfunction getBlogGenerationArgs() {\n  const components = createBlogComponents();\n  const { header, footer, wrapFunc } = components;\n  return { header, footer, wrapFunc };\n}\n\nexport const generateBlogOuter = (blog) => {\n  const { header, footer, wrapFunc } = getBlogGenerationArgs();\n  return generateBlog(blog, header, footer, wrapFunc);\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/src/generator/head.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/src/generator/html.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/src/generator/interactive.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/src/generator/main.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/src/generator/script.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/src/generator/styles.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/src/generator/title.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/src/toys/2024-10-02/hello.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/src/toys/2025-03-19/identity.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/src/toys/2025-03-21/booleanCoercer.js","messages":[{"ruleId":"complexity","severity":1,"message":"Function 'coerceToBoolean' has a complexity of 4. Maximum allowed is 3.","line":9,"column":8,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":22,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Coerces input to a boolean value if possible.\n * Returns a string representation of an object with a 'value' property if coercion is successful,\n * or a string representation of an empty object if coercion fails.\n *\n * @param {any} input - The value to coerce to boolean\n * @returns {string} - String representation of object with 'value' property if coercion successful, '{}' if not\n */\nexport function coerceToBoolean(input) {\n  const booleanMap = {\n    true: true,\n    false: false\n  };\n\n  if (typeof input === 'boolean') {\n    return `{ value: ${input} }`;\n  }\n\n  const normalized = (typeof input === 'string') ? booleanMap[input.toLowerCase()] : undefined;\n\n  return typeof normalized === 'boolean' ? `{ value: ${normalized} }` : '{}';\n}","usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/src/toys/2025-03-21/italics.js","messages":[{"ruleId":"complexity","severity":1,"message":"Function 'processTextPreservingBold' has a complexity of 4. Maximum allowed is 3.","line":90,"column":1,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":101,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Markdown marker characters\nconst ASTERISK_MARKER = '*';\nconst UNDERSCORE_MARKER = '_';\n\n// Pattern to match special regex characters that need escaping\nconst REGEX_SPECIAL_CHARS = /[.*+?^${}()|[\\]\\\\]/;\n\n/**\n * Creates a doubled marker (e.g., ** or __) for bold text\n * @param {string} marker - The marker character (* or _)\n * @returns {string} - The doubled marker\n * @private\n */\nfunction createDoubledMarker(marker) {\n  return marker.repeat(2);\n}\n\n/**\n * Creates a regex pattern part for bold text with a specific marker\n * @param {string} marker - The marker character (* or _)\n * @returns {string} - Regex pattern string for bold with the specified marker\n * @private\n */\nfunction createBoldPatternPart(marker) {\n  // Escape marker if it's a special regex character\n  const escapedMarker = REGEX_SPECIAL_CHARS.test(marker) ? `\\\\${marker}` : marker;\n  const doubledMarker = createDoubledMarker(escapedMarker);\n  \n  // Break the pattern into its constituent parts\n  const patternParts = [\n    '(?:', // Opening non-capturing group\n    doubledMarker, // Opening doubled marker\n    '.*?', // Lazy match of content\n    doubledMarker, // Closing doubled marker\n    ')' // Closing group\n  ];\n  \n  return patternParts.join('');\n}\n\n/**\n * Returns a regex pattern that matches both asterisk and underscore bold markdown\n * @returns {RegExp} - The regex pattern for bold markdown\n * @private\n */\nfunction createBoldPattern() {\n  const boldMarkers = [ASTERISK_MARKER, UNDERSCORE_MARKER];\n  const patternParts = boldMarkers.map(createBoldPatternPart);\n  \n  // Combine with OR operator for alternative matching\n  const pattern = patternParts.join('|');\n  \n  return new RegExp(pattern, 's');\n}\n\n/**\n * Returns a regex pattern that matches text wrapped with a specific marker\n * @param {string} marker - The marker character (* or _)\n * @returns {RegExp} - The regex pattern for the specified marker\n * @private\n */\nfunction createItalicsPattern(marker) {\n  // Escape marker if it's a special regex character\n  const escapedMarker = REGEX_SPECIAL_CHARS.test(marker) ? `\\\\${marker}` : marker;\n  return new RegExp(`${escapedMarker}(.*?)${escapedMarker}`, 'g');\n}\n\n/**\n * Returns the array of markers used for italic styles\n * @returns {Array} - Array of marker characters\n * @private\n */\nfunction getItalicMarkers() {\n  return [ASTERISK_MARKER, UNDERSCORE_MARKER];\n}\n\n/**\n * Process text recursively to handle all formatting cases, preserving bold segments.\n * This function identifies bold markdown segments and leaves them unmodified,\n * while processing the text before and after for italic formatting.\n * \n * @example\n * // Returns: '**bold** <em>*italic*</em>'\n * processTextPreservingBold('**bold** *italic*');\n * \n * @param {string} text - The text to process\n * @returns {string} - Processed text with HTML tags added around italics while preserving bold\n * @private\n */\nfunction processTextPreservingBold(text) {\n  if (!text?.trim()) return '';\n\n  const segment = findBoldSegments(text);\n  if (!segment) return processAllItalicStyles(text);\n\n  return [\n    processItalicBefore(segment.beforeText),\n    segment.boldText,\n    processBoldAfter(segment.afterText)\n  ].filter(Boolean).join('');\n}\n\nfunction processItalicBefore(beforeText) {\n  return beforeText ? processAllItalicStyles(beforeText) : '';\n}\n\nfunction processBoldAfter(afterText) {\n  return afterText ? processTextPreservingBold(afterText) : '';\n}\n\n// Main exported function\n\n/**\n * Adds HTML <em> tags around text marked with Markdown italics while preserving\n * the original Markdown characters.\n * \n * Handles both *single asterisk* and _underscore_ style Markdown italics.\n * Does NOT add <em> tags around bold markdown syntax (** or __).\n * \n * @example\n * // Returns: '<em>*italic*</em> text'\n * italics('*italic* text');\n * \n * @example\n * // Returns: '<em>_italic_</em> text'\n * italics('_italic_ text');\n * \n * @example\n * // Returns: '**bold** and <em>*italic*</em>'\n * italics('**bold** and *italic*');\n * \n * @param {string} text - The input text that may contain Markdown italics syntax\n * @returns {string} Text with HTML <em> tags added around Markdown-formatted italics\n */\nexport function italics(text) {\n  if (!text || typeof text !== 'string') {\n    return text;\n  }\n  \n  // We'll use a recursive approach with special handling for bold segments\n  return processTextPreservingBold(text);\n}\n\n// Helper functions for processing text\n\n/**\n * Find bold segments in text and split into bold text and surrounding text\n * \n * @param {string} text - The text to process\n * @returns {Object|null} - Object with boldText, beforeText, and afterText properties, or null if no bold found\n * @private\n */\nfunction findBoldSegments(text) {\n  const boldMatch = text.match(createBoldPattern());\n  \n  if (!boldMatch) {\n    return null;\n  }\n  \n  const boldText = boldMatch[0];\n  const boldStartIndex = boldMatch.index;\n  const boldEndIndex = boldStartIndex + boldText.length;\n  \n  return {\n    boldText,\n    beforeText: text.substring(0, boldStartIndex),\n    afterText: text.substring(boldEndIndex)\n  };\n}\n\n/**\n * Apply italic formatting for a specific marker to the text\n * @param {string} text - The text to process\n * @param {string} marker - The marker character (* or _)\n * @returns {string} - Text with the particular italic style formatted\n * @private\n */\nfunction applyItalicFormatting(text, marker) {\n  const pattern = createItalicsPattern(marker);\n  return text.replace(pattern, (match, capturedContent) => {\n    return createItalicReplacementString(capturedContent, marker);\n  });\n}\n\n/**\n * Process text through all italic style types (asterisk and underscore)\n * \n * @example\n * // Returns: '<em>*text*</em>'\n * processAllItalicStyles('*text*');\n * \n * @example\n * // Returns: '<em>_text_</em>'\n * processAllItalicStyles('_text_');\n * \n * @param {string} text - The text to process \n * @returns {string} - Text with all italic styles formatted\n * @private\n */\nfunction processAllItalicStyles(text) {\n  // Process the text through all italic markers using reduce\n  return getItalicMarkers().reduce(applyItalicFormatting, text);\n}\n\n/**\n * Wrap content with a marker at the beginning and end\n * @param {string} content - The content to wrap\n * @param {string} marker - The marker to add at beginning and end\n * @returns {string} - Content wrapped with markers\n * @private\n */\nfunction wrapWithMarker(content, marker) {\n  return `${marker}${content}${marker}`;\n}\n\n/**\n * Create an HTML tag wrapper for content\n * @param {string} tagName - The HTML tag name (without brackets)\n * @param {string} content - The content to wrap\n * @returns {string} - The content wrapped in the HTML tag\n * @private\n */\nfunction wrapWithHtmlTag(tagName, content) {\n  return [`<${tagName}>`, content, `</${tagName}>`].join('');\n}\n\n/**\n * Create a replacement string for italic markdown content\n * @param {string} content - The inner content of the markdown\n * @param {string} marker - The markdown marker character (* or _)\n * @returns {string} - HTML formatted replacement string\n * @private\n */\nfunction createItalicReplacementString(content, marker) {\n  // First wrap content with markdown markers, then with HTML tag\n  return wrapWithHtmlTag('em', wrapWithMarker(content, marker));\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/test/generator/generator.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/test/toys/2024-10-02/hello.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/test/toys/2025-03-19/identity.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/test/toys/2025-03-21/booleanCoercer.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/test/toys/2025-03-21/italics.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]