# Copy workflow lockdown

- **Unexpected:** The copy pipeline had been copying almost every shared directory (blog.json, presenters, input handlers, constants, root wrappers, etc.), so when the product owner asked to limit the output to `src/browser`, `src/core/browser`, and the root JS files under `src/core`, I realized the workflow was deeply entangled with those previously duplicated helpers.
- **Diagnosis & options:** I rewired `src/core/copy.js` to only copy the two browser trees and the immediate JS files in `src/core`, dropped the old helpers, and re-aligned `test/core/copy.test.js` to validate that behavior (instead of spying on the now-internal helpers). The new unit tests verify that the browser directories are processed and that `copyCoreRootFiles` still triggers the intended logger messages/warnings.
- **Learning:** When shrinking a copy pipeline, it helps to keep the verification on the externally observable effects (logger messages and FS reads) rather than trying to spy on inner helper closures—otherwise Jest’s spies miss the bound reference. I also confirmed the suite with `npm test` to ensure nothing else depended on the removed helpers.
- **Follow-up:** If more root-level modules or shared helpers appear, consider adding explicit source lists again or providing a configuration-driven map so we don't accidentally start copying back the whole tree; also keep an eye on whether the `public/core/copy.js` bundle needs to stay in sync when the source helper changes.
- **Open question:** Should we also reform the generated `public/core/copy.js` (or automate it via the generator) so that a future run doesn't unexpectedly reintroduce the broader copy logic?
