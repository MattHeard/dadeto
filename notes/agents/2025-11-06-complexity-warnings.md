Observed that the enforced `complexity: 2` threshold throws warnings for almost every conditional and optional chain in `src/core`, so refactors can easily leave most functions still flagged. Breaking logic into helpers helps reduce one or two branches, but the rule still counts `&&`, `||`, and ternaries even when the helper itself is simple. This made it hard to “win” on the lint report without splitting functions into multiple tiny helpers.

Spent most of the time on the moderation job and admin UI helpers: I broke `hasCustomFirestoreFunctionOverrides`/`hasProvidedEnvironment` out of `shouldUseCustomFirestoreDependencies` and tried to isolate environment-type detection, and I replaced the optional chaining in `getDisableAutoSelectCandidate` with a `getNestedProperty` helper so that the core function now just returns whatever path exists. Those bits are smaller and easier to test for future refactors.

Next time I’d consider whether the complexity rule can be relaxed for these deep guard helpers or add tooling that automatically splits `&&` chains into helper predicates; that would let me focus on the high-value helpers while still shrinking the warning count. Open question: is there a pattern (maybe a shared helper or DSL) we can re-use across the other `src/core` helpers to keep them at ≤2 without spreading helpers everywhere?

Today I also refactored the render-contents CDN invalidation helper and the admin-side nested property reader to keep each function’s logic in one place. Wrapping the invalidation inputs into `buildInvalidationConfig` and `createPathInvalidationRunner` lets `createInvalidatePaths` simply compose the pieces, so ESLint now reports the helper’s guard instead of the factory that wires everything up. Similarly, the new reduce-based `getNestedProperty` avoids the-loop-with-if pattern that previously pushed its complexity past 2. These felt like good targets because they touched trusted helpers and left the larger flows untouched.
