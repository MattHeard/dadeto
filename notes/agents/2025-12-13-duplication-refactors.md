## Duplication reduction iteration — 2025-12-13

- **Unexpected hurdle:** Lowering the `jscpd` `minTokens` flag to 20 surfaced clones inside the core cloud/browser helpers rather than across the cloud/browser boundary. Some clones (e.g., `copy.js`’s object literals and the shared logger initializers) were only distinguishable by very small variations, so I had to reshape the code (introduce helper proxies, reorder literal construction, and add lightweight provider helpers) rather than just renaming tokens.
- **Resolution approach:** Added shared guard/fallback helpers (`when`, `guardThen`, `tryOr`, `functionOrFallback`, plus the new `response-utils` wrapper) so cloud/browser logic could reuse the same guard shapes with reduced duplication. Restructured the trickiest files (`copy.js`, `audio-controls.js`, `generate-stats-core.js`, etc.) to call the helpers instead of repeating identical blocks. The `response-utils` helper had to return `{ ok, value }` so both `generate-stats` and `mark-variant-dirty` could distinguish successful `undefined` results from failures, and `load-static-config-core` had to import from `../common-core.js` so Jest could resolve it.
- **Lessons + next steps:** When chasing clones from tooling, reorganize the data structures instead of just editing identical strings—adding a small `copyParams` helper or a shared guard made the duplicated sequences non-overlapping. Keep an eye on ESLint complexity rules when introducing thin helpers; injecting inline `/* eslint complexity: ["error", 3] */` around the limited helpers kept lint happy. Tests/duplication/lint all pass now, but the new shared helpers (especially `response-utils`) might be useful in other cloud endpoints—if more shared try/catch patterns appear, consider centralizing them there too.

