[{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/babel.config.cjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/copy-toys.js","messages":[{"ruleId":"complexity","severity":1,"message":"Function 'handleEntry' has a complexity of 3. Maximum allowed is 2.","line":49,"column":1,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":58,"endColumn":2},{"ruleId":"complexity","severity":1,"message":"Function 'shouldCopy' has a complexity of 3. Maximum allowed is 2.","line":60,"column":1,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":62,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\n\n/**\n * This script copies toy JavaScript files from src/toys to public\n * It preserves the directory structure\n */\n\nimport fs from 'fs';\nimport path from 'path';\nimport { fileURLToPath } from 'url';\n\n// Get the directory name of the current module\nconst __dirname = path.dirname(fileURLToPath(import.meta.url));\n\n// Source and destination directories\nconst srcDir = path.join(__dirname, 'src', 'toys');\nconst destDir = path.join(__dirname, 'public');\n\n/**\n * Copy a file from source to destination\n * @param {string} src - Source file path\n * @param {string} dest - Destination file path\n */\nfunction copyFile(src, dest) {\n  // Create destination directory if it doesn't exist\n  const destDir = path.dirname(dest);\n  if (!fs.existsSync(destDir)) {\n    fs.mkdirSync(destDir, { recursive: true });\n  }\n  \n  // Copy the file\n  fs.copyFileSync(src, dest);\n  console.log(`Copied: ${src} -> ${dest}`);\n}\n\n/**\n * Recursively copy files from source to destination\n * @param {string} src - Source directory\n * @param {string} dest - Destination directory\n */\nfunction copyToyFiles(src, dest) {\n  const entries = fs.readdirSync(src, { withFileTypes: true });\n\n  for (const entry of entries) {\n    handleEntry(entry, src, dest);\n  }\n}\n\nfunction handleEntry(entry, src, dest) {\n  const srcPath = path.join(src, entry.name);\n\n  if (entry.isDirectory()) {\n    copyToyFiles(srcPath, dest);\n  } else if (shouldCopy(entry)) {\n    const destPath = getDestPath(srcPath);\n    copyFile(srcPath, destPath);\n  }\n}\n\nfunction shouldCopy(entry) {\n  return entry.isFile() && entry.name.endsWith('.js') && !entry.name.endsWith('.test.js');\n}\n\nfunction getDestPath(srcPath) {\n  const relativePath = path.relative(srcDir, srcPath);\n  return path.join(destDir, relativePath);\n}\n\n// Execute the copy function\ncopyToyFiles(srcDir, destDir);\nconsole.log('Toy files copied successfully!');\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/eslint.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/generate.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/jest.config.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/src/generator/full-width.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/src/generator/generator.js","messages":[{"ruleId":"complexity","severity":1,"message":"Function 'createArticleClassAttr' has a complexity of 3. Maximum allowed is 2.","line":332,"column":1,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":344,"endColumn":2},{"ruleId":"complexity","severity":1,"message":"Function 'hasModulePath' has a complexity of 3. Maximum allowed is 2.","line":788,"column":1,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":790,"endColumn":2},{"ruleId":"complexity","severity":1,"message":"Function 'hasFunctionName' has a complexity of 3. Maximum allowed is 2.","line":792,"column":1,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":794,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Create paragraphs HTML string.\n * @param {string|string[]} content - A string or an array of strings.\n * @returns {string} - HTML string composed of paragraph elements.\n */\nfunction createParagraphs(content) {\n  if (Array.isArray(content)) {\n    return content.map(para => `<p>${para}</p>`).join('');\n  } else {\n    return `<p>${content}</p>`;\n  }\n}\n\n/**\n * Create a blockquote HTML string.\n * @param {string|string[]} content - A string or an array of strings.\n * @returns {string} - The blockquote HTML.\n */\nfunction createBlockquote(content) {\n  return `<blockquote class=\"${CLASS.VALUE}\">${BLOCKQUOTE_CORNERS}${createParagraphs(content)}</blockquote>`;\n}\nimport { headElement } from './head.js';\nimport { fullWidthElement } from './full-width.js';\nimport { HEADER_BANNER } from './title.js';\nimport {\n  createTag,\n  createAttrPair,\n  escapeHtml,\n  wrapHtml,\n  join,\n  ATTR_NAME,\n} from './html.js';\n\n// CSS class names\nconst CLASS = {\n  KEY: 'key',\n  VALUE: 'value',\n  ENTRY: 'entry',\n  ARTICLE_TITLE: 'article-title',\n  METADATA: 'metadata',\n  FOOTER: 'footer',\n  WARNING: 'warning',\n  MEDIA: 'media',\n  FULL_WIDTH: 'full-width',\n};\n\nconst BLOCKQUOTE_CORNERS = `<div class=\"corner corner-tl\"><div class=\"h-line\"></div><div class=\"v-line\"></div></div><div class=\"corner corner-tr\"><div class=\"h-line\"></div><div class=\"v-line\"></div></div><div class=\"corner corner-bl\"><div class=\"h-line\"></div><div class=\"v-line\"></div></div><div class=\"corner corner-br\"><div class=\"h-line\"></div><div class=\"v-line\"></div></div>`;\n\n// HTML tag names\nconst DIV_TAG_NAME = 'div';\nconst ARTICLE_TAG_NAME = 'article';\n\n// Date formatting constants\nconst DATE_LOCALE = 'en-GB';\nconst DATE_FORMAT_OPTIONS = {\n  day: 'numeric',\n  month: 'short',\n  year: 'numeric',\n};\n\n// Container ID\nconst CONTAINER_ID = 'container';\n\n// HTML generation helpers\n\n/**\n * Create a div element with specified classes and content\n * @param {string} classes - CSS classes to apply to the div\n * @param {string} content - HTML content to place inside the div\n * @returns {string} - HTML div element\n */\nfunction createDiv(classes, content) {\n  const classAttr = createAttrPair(ATTR_NAME.CLASS, classes);\n  return createTag(DIV_TAG_NAME, classAttr, content);\n}\n\n/**\n * Join CSS classes into a space-separated string\n * @param {string[]} classes - Array of CSS class names\n * @returns {string} - Space-separated class string\n */\nfunction joinClasses(classes) {\n  return classes.join(' ');\n}\n\n/**\n * Create a div with the value class and optional additional classes\n * @param {string} content - Content for the value div\n * @param {string[]} additionalClasses - Additional CSS classes to apply\n * @returns {string} - HTML div element with value class and any additional classes\n */\nfunction createValueDiv(content, additionalClasses = []) {\n  const classes = [CLASS.VALUE, ...additionalClasses].filter(Boolean);\n  const joinedClasses = joinClasses(classes);\n  return createDiv(joinedClasses, content);\n}\n\n/**\n * Create an array with two parts for joining\n * @param {string} first - The first part\n * @param {string} second - The second part\n * @returns {Array<string>} - Array containing both parts\n */\nfunction createParts(first, second) {\n  return [first, second];\n}\n\n/**\n * Create a pair with two elements\n * @param {string} first - The first element\n * @param {string} second - The second element\n * @returns {string} - Combined HTML without newlines\n */\nfunction createPair(first, second) {\n  const parts = createParts(first, second);\n  return join(parts);\n}\n\n/**\n * Convert a date string to a Date object\n * @param {string} dateString - The date string to convert\n * @returns {Date} - The Date object\n */\nfunction createDateFromString(dateString) {\n  return new Date(dateString);\n}\n\n/**\n * Format a date using the locale and options\n * @param {Date} date - The date to format\n * @returns {string} - The formatted date string\n */\nfunction formatDateWithOptions(date) {\n  return date.toLocaleDateString(DATE_LOCALE, DATE_FORMAT_OPTIONS);\n}\n\n/**\n * Format date in \"4 May 2022\" format\n * @param {string} dateString - The date string to format\n * @returns {string} - The formatted date string\n */\nfunction formatDate(dateString) {\n  const date = createDateFromString(dateString);\n  return formatDateWithOptions(date);\n}\n\n// Header components\n\n// No longer using newlines and indentation\n\nconst METADATA_TEXT = `Software developer and philosopher in Berlin`;\n\n/**\n * Create an empty div with the key class\n * @returns {string} - HTML div element with key class and no content\n */\nfunction createEmptyKeyDiv() {\n  return createDiv(CLASS.KEY, '');\n}\n\nfunction prefixWithEmptyKey(valueDiv) {\n  const emptyKeyDiv = createEmptyKeyDiv();\n  return createPair(emptyKeyDiv, valueDiv);\n}\n\n/**\n * Create the content for the header section\n */\nfunction createHeaderContent() {\n  const valueDivs = [\n    createValueDiv(HEADER_BANNER),\n    createValueDiv(METADATA_TEXT, [CLASS.METADATA])\n  ];\n\n  const parts = valueDivs.map(prefixWithEmptyKey);\n  \n  return join(parts);\n}\n\n/**\n * Create a section with the given content\n * @param {string} content - The content to wrap in a section\n * @returns {string} - HTML for the section\n */\nfunction createSection(content) {\n  return createDiv(CLASS.ENTRY, content);\n}\n\n/**\n * Create the header section with banner and metadata\n * @returns {string} - HTML for the header section\n */\nfunction createHeaderSection() {\n  const headerContent = createHeaderContent();\n  return createSection(headerContent);\n}\n\n// Footer components\nconst WARNING_MESSAGE =\n  'All content is authored by Matt Heard and is <a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\">CC BY-NC-SA 4.0</a>, unless otherwise noted.';\n\n/**\n * Create the content for the footer section\n * @returns {string} - HTML for the footer content\n */\nfunction createFooterContent() {\n  const classes = joinClasses([CLASS.FOOTER, CLASS.VALUE, CLASS.WARNING]);\n  const footerDiv = createDiv(classes, WARNING_MESSAGE);\n  return prefixWithEmptyKey(footerDiv);\n}\n\n/**\n * Create the footer section with warning message\n * @returns {string} - HTML for the footer section\n */\nfunction createFooterSection() {\n  const footerContent = createFooterContent();\n  return createSection(footerContent);\n}\n\n// Page structure\n/**\n * Create the opening tag for the container div\n * @returns {string} - Opening div tag with container ID\n */\nfunction createContainerDivOpen() {\n  const idAttr = createAttrPair(ATTR_NAME.ID, CONTAINER_ID);\n  return `<${DIV_TAG_NAME} ${idAttr}>`;\n}\n\n/**\n * Create the header content array\n */\nfunction createHeaderContentArray(headerElement) {\n  return [\n    headElement,\n    '<body>',\n    createContainerDivOpen(),\n    '<!-- Header -->',\n    headerElement,\n  ];\n}\n\n/**\n * Create the page header with head element, body opening tag and header section\n */\nfunction createPageHeader() {\n  const headerElement = createHeaderSection();\n  const contentArray = createHeaderContentArray(headerElement);\n\n  return contentArray.join('');\n}\n\n/**\n * Create the closing container div\n */\nfunction createContainerDivClose() {\n  return '</div>';\n}\n\n/**\n * Create the body closing tag\n */\nfunction createBodyClose() {\n  return '</body>';\n}\n\n/**\n * Create the footer content array\n */\nfunction createFooterContentArray(footerElement) {\n  return [\n    '',\n    footerElement,\n    createContainerDivClose(),\n    '<script src=\"main.js\" defer></script>',\n    createBodyClose(),\n  ];\n}\n\n/**\n * Create the page footer with footer section, container div closing, and body closing tag\n */\nfunction createPageFooter() {\n  const footerElement = createFooterSection();\n  const contentArray = createFooterContentArray(footerElement);\n\n  return contentArray.join('');\n}\n\n/**\n * Convert a post to article HTML\n */\nfunction convertPostToArticleHTML(post) {\n  return generateArticle(post);\n}\n\n/**\n * Format article HTML with indentation\n */\nfunction formatArticleHTML(articleHTML) {\n  return articleHTML;\n}\n\n/**\n * Process posts and join article HTML\n */\nfunction processPostsToHTML(posts) {\n  return posts.map(convertPostToArticleHTML)\n              .map(formatArticleHTML)\n              .join('');\n}\n\n/**\n * Generate HTML for all articles in the blog\n */\nfunction generateArticles(posts) {\n  return processPostsToHTML(posts);\n}\n\n/**\n * Create attributes for an article element\n */\nfunction createIdAttributeIfNeeded(post) {\n  if (!post.key) {\n    return '';\n  }\n\n  return ' ' + createAttrPair(ATTR_NAME.ID, post.key);\n}\n\nfunction createArticleClassAttr(post) {\n  let tagClasses = '';\n\n  if (hasTags(post)) {\n    tagClasses = post.tags.map(tag => `tag-${tag}`).join(' ');\n  }\n\n  const classValue = tagClasses\n    ? `${CLASS.ENTRY} ${tagClasses}`\n    : CLASS.ENTRY;\n\n  return createAttrPair(ATTR_NAME.CLASS, classValue);\n}\n\nfunction createArticleAttributes(post) {\n  const classAttr = createArticleClassAttr(post);\n  const idAttr = createIdAttributeIfNeeded(post);\n  return `${classAttr}${idAttr}`;\n}\n\n/**\n * Format article content with full width element\n */\nfunction formatArticleContent(content) {\n  return `${fullWidthElement}${content}`;\n}\n\n/**\n * Create an article from a blog post\n */\nfunction generateArticle(post) {\n  const content = generateArticleContent(post);\n  const formattedContent = formatArticleContent(content);\n  const attributes = createArticleAttributes(post);\n\n  return createTag(ARTICLE_TAG_NAME, attributes, formattedContent);\n}\n\n/**\n * Get content array from post, defaulting to empty array if not present\n */\nfunction getContentArray(post) {\n  return post.content || [];\n}\n\n/**\n * Determine if an item is the first in the content array\n */\nfunction isFirstContentItem(index) {\n  return index === 0;\n}\n\n/**\n * Create a content item with index awareness\n */\nfunction createContentItemWithIndex(text, index) {\n  const isFirst = isFirstContentItem(index);\n  return createContentSectionItem(text, isFirst);\n}\n\nfunction isTextContent(content) {\n  return typeof content !== 'object' || content === null;\n}\n\n/**\n * Normalize a content item.\n * If content is already an object, return it unchanged;\n * otherwise, wrap it in an object with type 'text' and content fields.\n * @param {Object|string} content - The content item to normalize.\n * @returns {Object} - Normalized content object.\n */\nfunction normalizeContentItem(content) {\n  return isTextContent(content) ? { type: 'text', content } : content;\n}\n\n/**\n * Mapping of content types to their renderer functions.\n */\nconst CONTENT_RENDERERS = {\n  quote: createBlockquote,\n};\n\nfunction renderValueDiv(normalizedContent) {\n  const { type, content } = normalizedContent;\n \n  if (shouldRenderAsBlockquote(type, content)) {\n    return CONTENT_RENDERERS.quote(content);\n  }\n \n  return renderAsParagraph(content);\n}\n\nfunction isArrayTextQuote(type, content) {\n  return type === 'text' && Array.isArray(content);\n}\n\nfunction shouldRenderAsBlockquote(type, content) {\n  return type === 'quote' || isArrayTextQuote(type, content);\n}\n\nfunction renderAsParagraph(content) {\n  return `<p class=\"${CLASS.VALUE}\">${content}</p>`;\n}\n\n/**\n * Create a content section item with exact formatting\n * @param {Object|string} content - The content object or text\n * @param {boolean} isFirst - Whether this is the first content item\n * @returns {string} - Formatted content section HTML\n */\nfunction createContentSectionItem(content, isFirst) {\n  const normalizedContent = normalizeContentItem(content);\n  const key = isFirst ? 'text' : '';\n  const keyDiv = createDiv(CLASS.KEY, key);\n  const valueDiv = renderValueDiv(normalizedContent);\n \n  return formatSection(keyDiv, valueDiv);\n}\n\n/**\n * Generate the text content sections for a blog post\n */\nfunction generateContentSections(post) {\n  const contentArray = getContentArray(post);\n\n  const contentItems = contentArray.map(createContentItemWithIndex);\n\n  return combineHTMLSections(...contentItems);\n}\n\n/**\n * Generate header section for a blog post\n */\nfunction generateHeaderSection(post) {\n  const titleSection = generateTitleSection(post);\n  const dateSection = generateDateSection(post);\n  const tagsSection = generateTagsSection(post);\n\n  return combineHTMLSections(titleSection, dateSection, tagsSection);\n}\n\n/**\n * Create the title value for a blog post\n */\nfunction createTitleValue(post) {\n  const titleLink = `<a href=\"#${post.key}\">${post.title}</a>`;\n  const titleHeader = `<h2>${titleLink}</h2>`;\n  return `<div class=\"${CLASS.VALUE}\">${titleHeader}</div>`;\n}\n\n/**\n * Generate the title section for a blog post\n */\nfunction generateTitleSection(post) {\n  const titleClasses = joinClasses([CLASS.KEY, CLASS.ARTICLE_TITLE]);\n  const titleKey = createDiv(titleClasses, post.key);\n  const titleValue = createTitleValue(post);\n\n  return createPair(titleKey, titleValue);\n}\n\n/**\n * Generate the date section for a blog post\n */\nfunction generateDateSection(post) {\n  if (!post.publicationDate) {\n    return '';\n  }\n\n  const dateKey = createDiv(CLASS.KEY, 'pubAt');\n  const dateValue = `<p class=\"${CLASS.VALUE} ${CLASS.METADATA}\">${formatDate(post.publicationDate)}</p>`;\n\n  return createPair(dateKey, dateValue);\n}\n\n/**\n * Generate the tags section for a blog post\n * @param {Object} post - The blog post\n * @returns {string} - HTML for the tags section\n */\nfunction generateTagsSection(post) {\n  if (!hasTags(post)) {\n    return '';\n  }\n\n  const tagsKey = createDiv(CLASS.KEY, 'tags');\n  const tagsContent = post.tags.map(tag => {\n    const escapedTag = escapeHtml(tag);\n    return `<a class=\"tag-${escapedTag}\">${escapedTag}</a>`;\n  }).join(', ');\n  const tagsValue = `<p class=\"${CLASS.VALUE} ${CLASS.METADATA}\">${tagsContent}</p>`;\n\n  return createPair(tagsKey, tagsValue);\n}\n\n/**\n * Check if post has the specified media type\n */\nfunction hasMediaType(post, mediaType) {\n  return !!post[mediaType];\n}\n\nfunction isNonEmptyArray(value) {\n  return Array.isArray(value) && value.length > 0;\n}\n\n/**\n * Check if post has related links\n * @param {Object} post - The blog post\n * @returns {boolean} - True if post has related links\n */\nfunction hasRelatedLinks(post) {\n  return post.relatedLinks !== undefined && isNonEmptyArray(post.relatedLinks);\n}\n\n/**\n * Check if post has tags\n * @param {Object} post - The blog post\n * @returns {boolean} - True if post has tags\n */\nfunction hasTags(post) {\n  return Array.isArray(post.tags) && post.tags.length > 0;\n}\n\n/**\n * Check if post either is YouTube content or has a publication date\n */\nfunction isValidMediaType(post, mediaType) {\n  return mediaType === 'youtube' || post.publicationDate;\n}\n\n/**\n * Check if media should be displayed\n */\nfunction shouldDisplayMedia(post, mediaType) {\n  return hasMediaType(post, mediaType) && isValidMediaType(post, mediaType);\n}\n\n/**\n * Create a key div for media sections\n */\nfunction createMediaKeyDiv(label) {\n  const classes = `${CLASS.KEY} ${CLASS.MEDIA}`;\n  return createDiv(classes, label);\n}\n\n/**\n * Format a section with key and value divs\n * @param {string} keyDiv - The key div HTML\n * @param {string} valueDiv - The value div HTML\n * @returns {string} - Formatted section HTML\n */\nfunction formatSection(keyDiv, valueDiv) {\n  return `${keyDiv}${valueDiv}`;\n}\n\n/**\n * Generate media content based on media type\n */\nfunction generateMediaContent(post, mediaType) {\n  const generators = {\n    illustration: createIllustrationContent,\n    audio: createAudioContent,\n    youtube: createYouTubeContent\n  };\n\n  return (generators[mediaType] || (() => ''))(post);\n}\n\n/**\n * Higher-order function for generating media sections\n */\nfunction createMediaSectionGenerator(mediaType, label) {\n  return function (post) {\n    if (!shouldDisplayMedia(post, mediaType)) {\n      return '';\n    }\n\n    const keyDiv = createMediaKeyDiv(label);\n    const valueDiv = generateMediaContent(post, mediaType);\n\n    return formatSection(keyDiv, valueDiv);\n  };\n}\n\n/**\n * Create illustration image element\n */\nfunction createIllustrationImage(post) {\n  // Use fileName if provided, otherwise fall back to publicationDate\n  const fileName = post.illustration.fileName || post.publicationDate;\n  const src = `${fileName}.${post.illustration.fileType}`;\n  const altText = post.illustration.altText;\n\n  return `<img loading=\"lazy\" src=\"${src}\" alt=\"${altText}\"/>`;\n}\n\n/**\n * Create illustration content\n */\nfunction createIllustrationContent(post) {\n  const image = createIllustrationImage(post);\n\n  return `<div class=\"${CLASS.VALUE}\">${image}</div>`;\n}\n\n/**\n * Create audio source element\n */\nfunction createAudioSource(post) {\n  const audioSrc = `${post.publicationDate}.${post.audio.fileType}`;\n  return `<source src=\"${audioSrc}\">`;\n}\n\n/**\n * Create audio content\n */\nfunction createAudioContent(post) {\n  const source = createAudioSource(post);\n\n  return `<audio class=\"${CLASS.VALUE}\" controls>${source}</audio>`;\n}\n\n/**\n * Create YouTube iframe with proper attributes\n */\nfunction createYouTubeIframe(post) {\n  const youtubeId = post.youtube.id;\n  const timestamp = post.youtube.timestamp;\n  const title = escapeHtml(post.youtube.title);\n\n  return `<iframe height=\"300px\" width=\"100%\" src=\"https://www.youtube.com/embed/${youtubeId}?start=${timestamp}\" title=\"${title}\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" loading=\"lazy\" allowfullscreen></iframe>`;\n}\n\n/**\n * Create YouTube content\n */\nfunction createYouTubeContent(post) {\n  const iframe = createYouTubeIframe(post);\n\n  return `<p class=\"${CLASS.VALUE}\">${iframe}</p>`;\n}\n\n\n/**\n * Mapping for media sections.\n * Each key maps to a function that generates the corresponding media section.\n */\nconst MEDIA_SECTIONS = {\n  illustration: createMediaSectionGenerator('illustration', 'illus'),\n  audio: createMediaSectionGenerator('audio', 'audio'),\n  youtube: createMediaSectionGenerator('youtube', 'video'),\n};\n\n/**\n * Generate all media sections for a blog post by iterating over the MEDIA_SECTIONS mapping.\n */\nfunction generateMediaSections(post) {\n  const sections = Object.values(MEDIA_SECTIONS).map(generator => generator(post));\n  return combineHTMLSections(...sections);\n}\n\n/**\n * Format a related link to display in the list\n * @param {Object} link - The related link object\n * @returns {string} - Formatted HTML for a related link\n */\nconst DEFAULT_RELATED_LINK_ATTRS = 'target=\"_blank\" rel=\"noopener\"';\n\nfunction escapeRelatedLinkFields(link) {\n  const fields = ['url', 'title', 'author', 'source', 'quote'];\n  \n  return fields.reduce((acc, field) => {\n    acc[field] = link[field] ? escapeHtml(link[field]) : '';\n    return acc;\n  }, { type: link.type });\n}\n\nfunction formatTitleByType(type, title) {\n  const formatters = {\n    book: t => `<em>_${t}_</em>`,\n    microblog: t => `\"${t}\"`,\n    article: t => `\"${t}\"`,\n    report: t => `\"${t}\"`\n  };\n\n  return (formatters[type] || (t => t))(title);\n}\n\nfunction formatBaseLink(type, url, title) {\n  const formattedTitle = formatTitleByType(type, title);\n  return `<a href=\"${url}\" ${DEFAULT_RELATED_LINK_ATTRS}>${formattedTitle}</a>`;\n}\n\nfunction joinLinkParts(parts) {\n  return parts.filter(Boolean).join('');\n}\n\nfunction formatAuthor(author) {\n  return author ? ` by ${author}` : '';\n}\n\nfunction formatSource(source) {\n  return source ? `, ${source}` : '';\n}\n\nfunction formatQuote(quote) {\n  return quote ? ` (\"${quote}\")` : '';\n}\n\nfunction createLinkParts(baseLink, author, source, quote) {\n  return [\n    baseLink,\n    formatAuthor(author),\n    formatSource(source),\n    formatQuote(quote)\n  ];\n}\n\nfunction composeLinkParts(baseLink, author, source, quote) {\n  const parts = createLinkParts(baseLink, author, source, quote);\n  return `<li>${joinLinkParts(parts)}</li>`;\n}\n\nfunction formatRelatedLink(link) {\n  const { url, title, author, source, quote, type } = escapeRelatedLinkFields(link);\n  const baseLink = formatBaseLink(type, url, title);\n  return composeLinkParts(baseLink, author, source, quote);\n}\n\n/**\n * Generate the related links section for a blog post\n * @param {Object} post - The blog post\n * @returns {string} - HTML for the related links section\n */\nfunction generateRelatedLinksSection(post) {\n  if (!hasRelatedLinks(post)) {\n    return '';\n  }\n\n  const keyDiv = createDiv(CLASS.KEY, 'links');\n  // Join with an empty string to avoid spacing issues in the HTML output\n  const linksList = post.relatedLinks.map(link => formatRelatedLink(link)).join('');\n  const valueContent = `<ul class=\"related-links\">${linksList}</ul>`;\n  const valueDiv = createDiv(CLASS.VALUE, valueContent);\n\n  return formatSection(keyDiv, valueDiv);\n}\n\n/**\n * Combine multiple HTML sections into a single string\n */\nfunction combineHTMLSections(...sections) {\n  return sections.join('');\n}\n\nfunction hasModulePath(post) {\n  return !!post?.toy?.modulePath;\n}\n\nfunction hasFunctionName(post) {\n  return !!post?.toy?.functionName;\n}\n\n/**\n * Check if post has a toy component\n * @param {Object} post - The blog post\n * @returns {boolean} - True if post has a toy component\n */\nfunction hasToy(post) {\n  return hasModulePath(post) && hasFunctionName(post);\n}\n\n/**\n * Generate the input section for a toy component\n * @returns {string} - HTML for the input section\n */\nfunction generateToyInputSection() {\n  const keyDiv = createDiv(CLASS.KEY, 'in');\n  const valueContent = '<form><input type=\"text\" disabled></form>';\n  const valueDiv = createValueDiv(valueContent);\n  \n  return formatSection(keyDiv, valueDiv);\n}\n\n/**\n * Generate the button section for a toy component\n * @returns {string} - HTML for the button section\n */\nfunction generateToyButtonSection() {\n  const keyDiv = createEmptyKeyDiv();\n  const valueContent = '<button type=\"submit\" disabled>Submit</button>';\n  const valueDiv = createValueDiv(valueContent);\n  \n  return formatSection(keyDiv, valueDiv);\n}\n\n/**\n * Generate the output section for a toy component\n * @returns {string} - HTML for the output section\n */\nfunction generateToyOutputSection() {\n  const keyDiv = createDiv(CLASS.KEY, 'out');\n  const valueContent = '<p class=\"output\">This toy requires Javascript to run.</p>';\n  const valueDiv = createValueDiv(valueContent, [CLASS.WARNING]);\n  \n  return formatSection(keyDiv, valueDiv);\n}\n\n/**\n * Generate script tag to add the component\n * @param {Object} post - The blog post\n * @returns {string} - HTML script tag\n */\nfunction generateToyScript(post) {\n  const scriptContent = `window.addComponent('${post.key}', '${post.toy.modulePath}', '${post.toy.functionName}');`;\n  return `<script type=\"module\">${scriptContent}</script>`;\n}\n\n/**\n * Generate the toy UI components for a blog post\n * @param {Object} post - The blog post\n * @returns {string} - HTML for the toy UI components\n */\nfunction generateToyUISection(post) {\n  if (!hasToy(post)) {\n    return '';\n  }\n  \n  return combineHTMLSections(\n    generateToyInputSection(),\n    generateToyButtonSection(),\n    generateToyOutputSection()\n  );\n}\n\n/**\n * Generate the toy script section for a blog post\n * @param {Object} post - The blog post\n * @returns {string} - HTML for the toy script section\n */\nfunction generateToyScriptSection(post) {\n  if (!hasToy(post)) {\n    return '';\n  }\n  \n  return generateToyScript(post);\n}\n\n/**\n * Get all sections for a blog post article.\n * @param {Object} post - The blog post.\n * @returns {string[]} - An array of HTML sections.\n */\nfunction getArticleSections(post) {\n  const headerSection = generateHeaderSection(post);\n  const mediaSection = generateMediaSections(post);\n  const contentSection = generateContentSections(post);\n  const toyUISection = generateToyUISection(post);\n  const relatedLinksSection = generateRelatedLinksSection(post);\n  const toyScriptSection = generateToyScriptSection(post);\n \n  return [\n    headerSection,\n    mediaSection,\n    contentSection,\n    toyUISection,\n    relatedLinksSection,\n    toyScriptSection\n  ];\n}\n\n/**\n * Generate the content of a blog post article\n */\nfunction generateArticleContent(post) {\n  return combineHTMLSections(...getArticleSections(post));\n}\n\n/**\n * Create blog HTML content array\n */\nfunction createBlogContentArray(header, articles, footer) {\n  // Remove the newline character between elements\n  return [header, articles, footer];\n}\n\n/**\n * Build the complete HTML content for the blog from header, articles, and footer.\n * @param {string} header - The header HTML.\n * @param {string} articles - The articles HTML.\n * @param {string} footer - The footer HTML.\n * @returns {string} - Combined HTML content.\n */\nfunction getBlogHtmlContent(header, articles, footer) {\n  const contentArray = createBlogContentArray(header, articles, footer);\n  return contentArray.join('');\n}\n\n/**\n * Retrieve the HTML for all articles from the blog.\n * @param {Object} blog - The blog object.\n * @returns {string} - Combined HTML for all articles.\n */\nfunction getArticles(blog) {\n  return generateArticles(blog.posts);\n}\n\n/**\n * Assemble the blog HTML content by combining header, articles, and footer.\n * @param {string} header - The header HTML.\n * @param {Object} blog - The blog object.\n * @param {string} footer - The footer HTML.\n * @returns {string} - The combined HTML content.\n */\nfunction assembleBlogHTML(header, blog, footer) {\n  const articles = getArticles(blog);\n  return getBlogHtmlContent(header, articles, footer);\n}\n\nexport function generateBlog(blog, header, footer, wrapHtml) {\n  const htmlContents = assembleBlogHTML(header, blog, footer);\n  return wrapHtml(htmlContents);\n}\n\nconst createBlogComponents = () => ({\n  header: createPageHeader(),\n  footer: createPageFooter(),\n  wrapFunc: wrapHtml,\n});\n\n/**\n * Extracts the blog generation arguments from the blog components.\n * @returns {Object} - An object containing header, footer, and wrapFunc.\n */\nfunction getBlogGenerationArgs() {\n  const components = createBlogComponents();\n  const { header, footer, wrapFunc } = components;\n  return { header, footer, wrapFunc };\n}\n\nexport const generateBlogOuter = (blog) => {\n  const { header, footer, wrapFunc } = getBlogGenerationArgs();\n  return generateBlog(blog, header, footer, wrapFunc);\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/src/generator/head.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/src/generator/html.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/src/generator/interactive.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/src/generator/styles.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/src/generator/title.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/src/toys/2024-10-02/hello.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/src/toys/2025-03-19/identity.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/src/toys/2025-03-21/booleanCoercer.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/src/toys/2025-03-21/italics.js","messages":[{"ruleId":"complexity","severity":1,"message":"Function 'shouldBypassBold' has a complexity of 3. Maximum allowed is 2.","line":107,"column":1,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":109,"endColumn":2},{"ruleId":"complexity","severity":1,"message":"Function 'italics' has a complexity of 3. Maximum allowed is 2.","line":152,"column":8,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":159,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Markdown marker characters\nconst ASTERISK_MARKER = '*';\nconst UNDERSCORE_MARKER = '_';\n\n// Pattern to match special regex characters that need escaping\nconst REGEX_SPECIAL_CHARS = /[.*+?^${}()|[\\]\\\\]/;\n\n/**\n * Creates a doubled marker (e.g., ** or __) for bold text\n * @param {string} marker - The marker character (* or _)\n * @returns {string} - The doubled marker\n * @private\n */\nfunction createDoubledMarker(marker) {\n  return marker.repeat(2);\n}\n\n/**\n * Creates a regex pattern part for bold text with a specific marker\n * @param {string} marker - The marker character (* or _)\n * @returns {string} - Regex pattern string for bold with the specified marker\n * @private\n */\nfunction createBoldPatternPart(marker) {\n  // Escape marker if it's a special regex character\n  const escapedMarker = REGEX_SPECIAL_CHARS.test(marker) ? `\\\\${marker}` : marker;\n  const doubledMarker = createDoubledMarker(escapedMarker);\n  \n  // Break the pattern into its constituent parts\n  const patternParts = [\n    '(?:', // Opening non-capturing group\n    doubledMarker, // Opening doubled marker\n    '.*?', // Lazy match of content\n    doubledMarker, // Closing doubled marker\n    ')' // Closing group\n  ];\n  \n  return patternParts.join('');\n}\n\n/**\n * Returns a regex pattern that matches both asterisk and underscore bold markdown\n * @returns {RegExp} - The regex pattern for bold markdown\n * @private\n */\nfunction createBoldPattern() {\n  const boldMarkers = [ASTERISK_MARKER, UNDERSCORE_MARKER];\n  const patternParts = boldMarkers.map(createBoldPatternPart);\n  \n  // Combine with OR operator for alternative matching\n  const pattern = patternParts.join('|');\n  \n  return new RegExp(pattern, 's');\n}\n\n/**\n * Returns a regex pattern that matches text wrapped with a specific marker\n * @param {string} marker - The marker character (* or _)\n * @returns {RegExp} - The regex pattern for the specified marker\n * @private\n */\nfunction createItalicsPattern(marker) {\n  // Escape marker if it's a special regex character\n  const escapedMarker = REGEX_SPECIAL_CHARS.test(marker) ? `\\\\${marker}` : marker;\n  return new RegExp(`${escapedMarker}(.*?)${escapedMarker}`, 'g');\n}\n\n/**\n * Returns the array of markers used for italic styles\n * @returns {Array} - Array of marker characters\n * @private\n */\nfunction getItalicMarkers() {\n  return [ASTERISK_MARKER, UNDERSCORE_MARKER];\n}\n\n/**\n * Assembles the processed segments (before, bold, after) into a single string.\n * \n * @param {string} beforeText - The text before the bold segment\n * @param {string} boldText - The bold segment text\n * @param {string} afterText - The text after the bold segment\n * @returns {string} - The final assembled string after processing\n * @private\n */\nfunction assembleProcessedText(beforeText, boldText, afterText) {\n  return [\n    processItalicBefore(beforeText),\n    boldText,\n    processBoldAfter(afterText)\n  ].filter(Boolean).join('');\n}\n\n/**\n * Process text recursively to handle all formatting cases, preserving bold segments.\n * This function identifies bold markdown segments and leaves them unmodified,\n * while processing the text before and after for italic formatting.\n * \n * @example\n * // Returns: '**bold** <em>*italic*</em>'\n * processTextPreservingBold('**bold** *italic*');\n * \n * @param {string} text - The text to process\n * @returns {string} - Processed text with HTML tags added around italics while preserving bold\n * @private\n */\nfunction shouldBypassBold(text) {\n  return !text?.trim() || !findBoldSegments(text);\n}\n\nfunction processTextPreservingBold(text) {\n  if (shouldBypassBold(text)) {\n    return processAllItalicStyles(text);\n  }\n\n  const segment = findBoldSegments(text);\n  return assembleProcessedText(segment.beforeText, segment.boldText, segment.afterText);\n}\n\nfunction processItalicBefore(beforeText) {\n  return beforeText ? processAllItalicStyles(beforeText) : '';\n}\n\nfunction processBoldAfter(afterText) {\n  return afterText ? processTextPreservingBold(afterText) : '';\n}\n\n// Main exported function\n\n/**\n * Adds HTML <em> tags around text marked with Markdown italics while preserving\n * the original Markdown characters.\n * \n * Handles both *single asterisk* and _underscore_ style Markdown italics.\n * Does NOT add <em> tags around bold markdown syntax (** or __).\n * \n * @example\n * // Returns: '<em>*italic*</em> text'\n * italics('*italic* text');\n * \n * @example\n * // Returns: '<em>_italic_</em> text'\n * italics('_italic_ text');\n * \n * @example\n * // Returns: '**bold** and <em>*italic*</em>'\n * italics('**bold** and *italic*');\n * \n * @param {string} text - The input text that may contain Markdown italics syntax\n * @returns {string} Text with HTML <em> tags added around Markdown-formatted italics\n */\nexport function italics(text) {\n  if (!text || typeof text !== 'string') {\n    return text;\n  }\n  \n  // We'll use a recursive approach with special handling for bold segments\n  return processTextPreservingBold(text);\n}\n\n// Helper functions for processing text\n\n/**\n * Find bold segments in text and split into bold text and surrounding text\n * \n * @param {string} text - The text to process\n * @returns {Object|null} - Object with boldText, beforeText, and afterText properties, or null if no bold found\n * @private\n */\nfunction findBoldSegments(text) {\n  const boldMatch = text.match(createBoldPattern());\n  \n  if (!boldMatch) {\n    return null;\n  }\n  \n  const boldText = boldMatch[0];\n  const boldStartIndex = boldMatch.index;\n  const boldEndIndex = boldStartIndex + boldText.length;\n  \n  return {\n    boldText,\n    beforeText: text.substring(0, boldStartIndex),\n    afterText: text.substring(boldEndIndex)\n  };\n}\n\n/**\n * Apply italic formatting for a specific marker to the text\n * @param {string} text - The text to process\n * @param {string} marker - The marker character (* or _)\n * @returns {string} - Text with the particular italic style formatted\n * @private\n */\nfunction applyItalicFormatting(text, marker) {\n  const pattern = createItalicsPattern(marker);\n  return text.replace(pattern, (match, capturedContent) => {\n    return createItalicReplacementString(capturedContent, marker);\n  });\n}\n\n/**\n * Process text through all italic style types (asterisk and underscore)\n * \n * @example\n * // Returns: '<em>*text*</em>'\n * processAllItalicStyles('*text*');\n * \n * @example\n * // Returns: '<em>_text_</em>'\n * processAllItalicStyles('_text_');\n * \n * @param {string} text - The text to process \n * @returns {string} - Text with all italic styles formatted\n * @private\n */\nfunction processAllItalicStyles(text) {\n  // Process the text through all italic markers using reduce\n  return getItalicMarkers().reduce(applyItalicFormatting, text);\n}\n\n/**\n * Wrap content with a marker at the beginning and end\n * @param {string} content - The content to wrap\n * @param {string} marker - The marker to add at beginning and end\n * @returns {string} - Content wrapped with markers\n * @private\n */\nfunction wrapWithMarker(content, marker) {\n  return `${marker}${content}${marker}`;\n}\n\n/**\n * Create an HTML tag wrapper for content\n * @param {string} tagName - The HTML tag name (without brackets)\n * @param {string} content - The content to wrap\n * @returns {string} - The content wrapped in the HTML tag\n * @private\n */\nfunction wrapWithHtmlTag(tagName, content) {\n  return [`<${tagName}>`, content, `</${tagName}>`].join('');\n}\n\n/**\n * Create a replacement string for italic markdown content\n * @param {string} content - The inner content of the markdown\n * @param {string} marker - The markdown marker character (* or _)\n * @returns {string} - HTML formatted replacement string\n * @private\n */\nfunction createItalicReplacementString(content, marker) {\n  // First wrap content with markdown markers, then with HTML tag\n  return wrapWithHtmlTag('em', wrapWithMarker(content, marker));\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/src/toys/2025-03-26/prettyFloat.js","messages":[{"ruleId":"complexity","severity":1,"message":"Function 'decomposeFloat' has a complexity of 4. Maximum allowed is 2.","line":1,"column":8,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":16,"endColumn":2},{"ruleId":"complexity","severity":1,"message":"Function 'isZeroVariant' has a complexity of 3. Maximum allowed is 2.","line":18,"column":1,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":22,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export function decomposeFloat(input) {\n  const num = Number(input);\n  if (!Number.isFinite(num)) return \"\";\n\n  const zeroResult = isZeroVariant(num);\n  if (zeroResult !== null) return zeroResult;\n\n  const A = formatDecimal(num);\n\n  const parts = decomposeIEEE754(num);\n  if (!isValidIEEEParts(parts)) return \"\";\n\n  const { B, C } = getSignificandAndExponent(parts);\n\n  return `${A} (${B.toString()} × 2^${C.toString()})`;\n}\n\nfunction isZeroVariant(num) {\n  if (Object.is(num, 0)) return \"0 (0 × 2^0)\";\n  if (Object.is(num, -0)) return \"0 (-0 × 2^0)\";\n  return null;\n}\n\nfunction formatDecimal(num) {\n  let A = num.toPrecision(17);\n  return A.includes('.') ? A.replace(/\\.?0+$/, '') : A;\n}\n\nfunction hasIEEEFields(parts) {\n  return ['sign', 'mantissa', 'exponent'].every(key => key in parts);\n}\n\nfunction isValidIEEEParts(parts) {\n  return Boolean(parts) && hasIEEEFields(parts);\n}\n\nfunction getSignificandAndExponent({ sign, mantissa, exponent }) {\n  const signValue = sign === 0 ? 1n : -1n;\n  const fullSignificand = (1n << 52n) | BigInt(mantissa);\n  const B = signValue * fullSignificand;\n  const C = BigInt(exponent - 1023) - 52n;\n  return { B, C };\n}\n\nfunction decomposeIEEE754(value) {\n  if (!Number.isFinite(value)) return {};\n\n  const bits = getFloat64Bits(value);\n  return extractIEEEComponents(bits);\n}\n\nfunction getFloat64Bits(value) {\n  const buffer = new ArrayBuffer(8);\n  const floatView = new Float64Array(buffer);\n  const byteView = new Uint8Array(buffer);\n\n  floatView[0] = value;\n\n  let bits = 0n;\n  for (let i = 7; i >= 0; i--) {\n    bits = (bits << 8n) | BigInt(byteView[i]);\n  }\n\n  return bits;\n}\n\nfunction extractIEEEComponents(bits) {\n  const sign = Number((bits >> 63n) & 1n);\n  const exponentBits = (bits >> 52n) & 0x7FFn;\n  const mantissaBits = bits & 0xFFFFFFFFFFFFFn;\n\n  if (exponentBits === 0n) {\n    return {};\n  }\n\n  return {\n    sign,\n    mantissa: Number(mantissaBits),\n    exponent: Number(exponentBits),\n  };\n}","usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/src/toys/2025-03-28/rand.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/src/toys/2025-03-29/fishingGame.js","messages":[{"ruleId":"complexity","severity":1,"message":"Function 'getBaitData' has a complexity of 3. Maximum allowed is 2.","line":24,"column":1,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":33,"endColumn":2},{"ruleId":"complexity","severity":1,"message":"Function 'isWinterMonth' has a complexity of 3. Maximum allowed is 2.","line":54,"column":1,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":56,"endColumn":2},{"ruleId":"complexity","severity":1,"message":"Function 'getTimeOfDay' has a complexity of 5. Maximum allowed is 2.","line":58,"column":1,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":64,"endColumn":2},{"ruleId":"complexity","severity":1,"message":"Function 'getSeason' has a complexity of 5. Maximum allowed is 2.","line":74,"column":1,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":88,"endColumn":2},{"ruleId":"complexity","severity":1,"message":"Function 'getFishingOutcome' has a complexity of 4. Maximum allowed is 2.","line":118,"column":1,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":128,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"function isRecognizedBait(baitKey, baitOptions) {\n  return baitKey in baitOptions;\n}\n\nfunction isEmptyBait(baitKey) {\n  return baitKey.length === 0;\n}\n\nfunction getDefaultBaitResponse(moodDescription) {\n  return {\n    isError: true,\n    message: `You cast your line with nothing but hesitation. Without any bait, the waters remain undisturbed in their ${moodDescription}.`\n  };\n}\n\nfunction getRecognizedBait(baitKey, baitOptions) {\n  return baitOptions[baitKey];\n}\n\nfunction getUnrecognizedBait() {\n  return { modifier: 0, description: \"an unconventional bait\" };\n}\n\nfunction getBaitData(input, baitOptions, moodDescription) {\n  const baitKey = input.trim().toLowerCase();\n  if (isRecognizedBait(baitKey, baitOptions)) {\n    return getRecognizedBait(baitKey, baitOptions);\n  }\n  if (isEmptyBait(baitKey)) {\n    return getDefaultBaitResponse(moodDescription);\n  }\n  return getUnrecognizedBait();\n}\n\nfunction isMorningHour(hour) {\n  return hour >= 5 && hour < 12;\n}\n\nfunction isAfternoonHour(hour) {\n  return hour >= 12 && hour < 17;\n}\n\nfunction isEveningHour(hour) {\n  return hour >= 17 && hour < 21;\n}\n\nfunction isNightHour(hour) {\n  return hour < 5 || hour >= 21;\n}\n\nfunction isFallMonth(month) {\n  return month >= 8 && month <= 10;\n}\nfunction isWinterMonth(month) {\n  return month === 11 || month === 0 || month === 1;\n}\n\nfunction getTimeOfDay(hour) {\n  if (isMorningHour(hour)) return \"morning\";\n  if (isAfternoonHour(hour)) return \"afternoon\";\n  if (isEveningHour(hour)) return \"evening\";\n  if (isNightHour(hour)) return \"night\";\n  throw new Error(`Unrecognized hour: ${hour}`);\n}\n\nfunction isSpringMonth(month) {\n  return month >= 2 && month <= 4;\n}\n\nfunction isSummerMonth(month) {\n  return month >= 5 && month <= 7;\n}\n\nfunction getSeason(month) {\n  if (isWinterMonth(month)) {\n    return \"winter\";\n  }\n  if (isSpringMonth(month)) {\n    return \"spring\";\n  }\n  if (isSummerMonth(month)) {\n    return \"summer\";\n  }\n  if (isFallMonth(month)) {\n    return \"fall\";\n  }\n  throw new Error(`Unrecognized month: ${month}`);\n}\n\nfunction getMoodDescription(season, timeOfDay) {\n  const seasonDescriptions = {\n    winter: \"crisp, icy waters\",\n    spring: \"bubbling, fresh currents\",\n    summer: \"warm, shimmering waves\",\n    fall: \"cool, reflective ponds\",\n  };\n  const timeDescriptions = {\n    morning: \"as dawn breaks with promise\",\n    afternoon: \"under a vibrant sun\",\n    evening: \"in the glow of twilight\",\n    night: \"beneath a silent, starry sky\",\n  };\n  return `${seasonDescriptions[season]} ${timeDescriptions[timeOfDay]}`;\n}\n\nfunction isSilentCatch(chance) {\n  return chance < 0.3;\n}\n\nfunction isCommonCatch(chance) {\n  return chance < 0.6;\n}\n\nfunction isTroutCatch(chance) {\n  return chance < 0.85;\n}\n\nfunction getFishingOutcome(effectiveChance, baitDescription, moodDescription) {\n  if (isSilentCatch(effectiveChance)) {\n    return `the water stays silent. Despite your use of ${baitDescription}, no fish disturb the ${moodDescription}.`;\n  } else if (isCommonCatch(effectiveChance)) {\n    return `a common carp surfaces gently, a modest reward for your effort with ${baitDescription}, set against ${moodDescription}.`;\n  } else if (isTroutCatch(effectiveChance)) {\n    return `a glimmering trout appears briefly, its shimmer echoing the beauty of ${moodDescription}. Your choice of ${baitDescription} worked well.`;\n  } else {\n    return `in a burst of brilliance, a legendary golden fish leaps forth—its radiance matching the splendor of ${moodDescription}. Your ${baitDescription} has yielded a prize.`;\n  }\n}\n\nfunction getBaitOptions() {\n  return {\n    \"worm\": { modifier: 0.0, description: \"a wriggling worm\" },\n    \"insect\": { modifier: 0.05, description: \"a lively insect\" },\n    \"bread\": { modifier: -0.05, description: \"a slice of bread\" },\n    \"cheese\": { modifier: 0.1, description: \"a pungent piece of cheese\" },\n    \"shiny bait\": { modifier: 0.15, description: \"a glittering lure\" },\n    \"doughnut\": { modifier: 0.2, description: \"a tempting doughnut\" },\n    \"grub\": { modifier: 0.05, description: \"a succulent grub\" },\n    \"minnow\": { modifier: 0.1, description: \"a darting minnow\" },\n    \"sausage\": { modifier: 0.2, description: \"a savory sausage\" },\n    \"maggot\": { modifier: -0.1, description: \"a squirming maggot\" },\n  };\n}\n\nfunction getTimeContext(getCurrentTime) {\n  const date = new Date(getCurrentTime());\n  const month = date.getMonth();\n  const hour = date.getHours();\n  const season = getSeason(month);\n  const timeOfDay = getTimeOfDay(hour);\n  return { season, timeOfDay };\n}\n\nfunction fishingGame(input, env) {\n  const { season, timeOfDay } = getTimeContext(env.get(\"getCurrentTime\"));\n\n  const moodDescription = getMoodDescription(season, timeOfDay);\n\n  const baitOptions = getBaitOptions();\n\n  const baitDataOrError = getBaitData(input, baitOptions, moodDescription);\n  if (baitDataOrError.isError) return baitDataOrError.message;\n  const baitData = baitDataOrError;\n\n  const getRandomNumber = env.get(\"getRandomNumber\");\n  const baseChance = getRandomNumber();\n  const effectiveChance = Math.min(1, Math.max(0, baseChance + baitData.modifier));\n\n  const outcome = getFishingOutcome(effectiveChance, baitData.description, moodDescription);\n\n  return `Casting your line with ${baitData.description}, you await a catch. ${outcome}`;\n}\n\nexport { fishingGame };","usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/stryker.config.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/test/generator/generator.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/test/toys/2024-10-02/hello.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/test/toys/2025-03-19/identity.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/test/toys/2025-03-21/booleanCoercer.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/test/toys/2025-03-21/italics.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/test/toys/2025-03-26/prettyFloat.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/test/toys/2025-03-28/rand.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/test/toys/2025-03-29/fishingGame.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]