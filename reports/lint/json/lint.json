[{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/babel.config.cjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/eslint.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/generate.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/jest.config.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/src/generator/full-width.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/src/generator/generator.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/src/generator/head.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/src/generator/html.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/src/generator/interactive.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/src/generator/main.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/src/generator/script.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/src/generator/styles.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/src/generator/title.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/src/toys/2024-10-02/hello.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/src/toys/2025-03-19/identity.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/src/toys/2025-03-21/booleanCoercer.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/src/toys/2025-03-21/italics.js","messages":[{"ruleId":"complexity","severity":1,"message":"Function 'processTextPreservingBold' has a complexity of 4. Maximum allowed is 3.","line":107,"column":1,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":114,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Markdown marker characters\nconst ASTERISK_MARKER = '*';\nconst UNDERSCORE_MARKER = '_';\n\n// Pattern to match special regex characters that need escaping\nconst REGEX_SPECIAL_CHARS = /[.*+?^${}()|[\\]\\\\]/;\n\n/**\n * Creates a doubled marker (e.g., ** or __) for bold text\n * @param {string} marker - The marker character (* or _)\n * @returns {string} - The doubled marker\n * @private\n */\nfunction createDoubledMarker(marker) {\n  return marker.repeat(2);\n}\n\n/**\n * Creates a regex pattern part for bold text with a specific marker\n * @param {string} marker - The marker character (* or _)\n * @returns {string} - Regex pattern string for bold with the specified marker\n * @private\n */\nfunction createBoldPatternPart(marker) {\n  // Escape marker if it's a special regex character\n  const escapedMarker = REGEX_SPECIAL_CHARS.test(marker) ? `\\\\${marker}` : marker;\n  const doubledMarker = createDoubledMarker(escapedMarker);\n  \n  // Break the pattern into its constituent parts\n  const patternParts = [\n    '(?:', // Opening non-capturing group\n    doubledMarker, // Opening doubled marker\n    '.*?', // Lazy match of content\n    doubledMarker, // Closing doubled marker\n    ')' // Closing group\n  ];\n  \n  return patternParts.join('');\n}\n\n/**\n * Returns a regex pattern that matches both asterisk and underscore bold markdown\n * @returns {RegExp} - The regex pattern for bold markdown\n * @private\n */\nfunction createBoldPattern() {\n  const boldMarkers = [ASTERISK_MARKER, UNDERSCORE_MARKER];\n  const patternParts = boldMarkers.map(createBoldPatternPart);\n  \n  // Combine with OR operator for alternative matching\n  const pattern = patternParts.join('|');\n  \n  return new RegExp(pattern, 's');\n}\n\n/**\n * Returns a regex pattern that matches text wrapped with a specific marker\n * @param {string} marker - The marker character (* or _)\n * @returns {RegExp} - The regex pattern for the specified marker\n * @private\n */\nfunction createItalicsPattern(marker) {\n  // Escape marker if it's a special regex character\n  const escapedMarker = REGEX_SPECIAL_CHARS.test(marker) ? `\\\\${marker}` : marker;\n  return new RegExp(`${escapedMarker}(.*?)${escapedMarker}`, 'g');\n}\n\n/**\n * Returns the array of markers used for italic styles\n * @returns {Array} - Array of marker characters\n * @private\n */\nfunction getItalicMarkers() {\n  return [ASTERISK_MARKER, UNDERSCORE_MARKER];\n}\n\n/**\n * Assembles the processed segments (before, bold, after) into a single string.\n * \n * @param {string} beforeText - The text before the bold segment\n * @param {string} boldText - The bold segment text\n * @param {string} afterText - The text after the bold segment\n * @returns {string} - The final assembled string after processing\n * @private\n */\nfunction assembleProcessedText(beforeText, boldText, afterText) {\n  return [\n    processItalicBefore(beforeText),\n    boldText,\n    processBoldAfter(afterText)\n  ].filter(Boolean).join('');\n}\n\n/**\n * Process text recursively to handle all formatting cases, preserving bold segments.\n * This function identifies bold markdown segments and leaves them unmodified,\n * while processing the text before and after for italic formatting.\n * \n * @example\n * // Returns: '**bold** <em>*italic*</em>'\n * processTextPreservingBold('**bold** *italic*');\n * \n * @param {string} text - The text to process\n * @returns {string} - Processed text with HTML tags added around italics while preserving bold\n * @private\n */\nfunction processTextPreservingBold(text) {\n  if (!text?.trim()) return '';\n\n  const segment = findBoldSegments(text);\n  if (!segment) return processAllItalicStyles(text);\n\n  return assembleProcessedText(segment.beforeText, segment.boldText, segment.afterText);\n}\n\nfunction processItalicBefore(beforeText) {\n  return beforeText ? processAllItalicStyles(beforeText) : '';\n}\n\nfunction processBoldAfter(afterText) {\n  return afterText ? processTextPreservingBold(afterText) : '';\n}\n\n// Main exported function\n\n/**\n * Adds HTML <em> tags around text marked with Markdown italics while preserving\n * the original Markdown characters.\n * \n * Handles both *single asterisk* and _underscore_ style Markdown italics.\n * Does NOT add <em> tags around bold markdown syntax (** or __).\n * \n * @example\n * // Returns: '<em>*italic*</em> text'\n * italics('*italic* text');\n * \n * @example\n * // Returns: '<em>_italic_</em> text'\n * italics('_italic_ text');\n * \n * @example\n * // Returns: '**bold** and <em>*italic*</em>'\n * italics('**bold** and *italic*');\n * \n * @param {string} text - The input text that may contain Markdown italics syntax\n * @returns {string} Text with HTML <em> tags added around Markdown-formatted italics\n */\nexport function italics(text) {\n  if (!text || typeof text !== 'string') {\n    return text;\n  }\n  \n  // We'll use a recursive approach with special handling for bold segments\n  return processTextPreservingBold(text);\n}\n\n// Helper functions for processing text\n\n/**\n * Find bold segments in text and split into bold text and surrounding text\n * \n * @param {string} text - The text to process\n * @returns {Object|null} - Object with boldText, beforeText, and afterText properties, or null if no bold found\n * @private\n */\nfunction findBoldSegments(text) {\n  const boldMatch = text.match(createBoldPattern());\n  \n  if (!boldMatch) {\n    return null;\n  }\n  \n  const boldText = boldMatch[0];\n  const boldStartIndex = boldMatch.index;\n  const boldEndIndex = boldStartIndex + boldText.length;\n  \n  return {\n    boldText,\n    beforeText: text.substring(0, boldStartIndex),\n    afterText: text.substring(boldEndIndex)\n  };\n}\n\n/**\n * Apply italic formatting for a specific marker to the text\n * @param {string} text - The text to process\n * @param {string} marker - The marker character (* or _)\n * @returns {string} - Text with the particular italic style formatted\n * @private\n */\nfunction applyItalicFormatting(text, marker) {\n  const pattern = createItalicsPattern(marker);\n  return text.replace(pattern, (match, capturedContent) => {\n    return createItalicReplacementString(capturedContent, marker);\n  });\n}\n\n/**\n * Process text through all italic style types (asterisk and underscore)\n * \n * @example\n * // Returns: '<em>*text*</em>'\n * processAllItalicStyles('*text*');\n * \n * @example\n * // Returns: '<em>_text_</em>'\n * processAllItalicStyles('_text_');\n * \n * @param {string} text - The text to process \n * @returns {string} - Text with all italic styles formatted\n * @private\n */\nfunction processAllItalicStyles(text) {\n  // Process the text through all italic markers using reduce\n  return getItalicMarkers().reduce(applyItalicFormatting, text);\n}\n\n/**\n * Wrap content with a marker at the beginning and end\n * @param {string} content - The content to wrap\n * @param {string} marker - The marker to add at beginning and end\n * @returns {string} - Content wrapped with markers\n * @private\n */\nfunction wrapWithMarker(content, marker) {\n  return `${marker}${content}${marker}`;\n}\n\n/**\n * Create an HTML tag wrapper for content\n * @param {string} tagName - The HTML tag name (without brackets)\n * @param {string} content - The content to wrap\n * @returns {string} - The content wrapped in the HTML tag\n * @private\n */\nfunction wrapWithHtmlTag(tagName, content) {\n  return [`<${tagName}>`, content, `</${tagName}>`].join('');\n}\n\n/**\n * Create a replacement string for italic markdown content\n * @param {string} content - The inner content of the markdown\n * @param {string} marker - The markdown marker character (* or _)\n * @returns {string} - HTML formatted replacement string\n * @private\n */\nfunction createItalicReplacementString(content, marker) {\n  // First wrap content with markdown markers, then with HTML tag\n  return wrapWithHtmlTag('em', wrapWithMarker(content, marker));\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/src/toys/2025-03-26/prettyFloat.js","messages":[{"ruleId":"complexity","severity":1,"message":"Function 'decomposeFloat' has a complexity of 10. Maximum allowed is 3.","line":15,"column":8,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":50,"endColumn":2},{"ruleId":"complexity","severity":1,"message":"Function 'decomposeIEEE754' has a complexity of 4. Maximum allowed is 3.","line":52,"column":1,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":82,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Decomposes a finite JavaScript number into a string of the form:\n *\n *    \"A (B × 2^C)\"\n *\n * where:\n *   - A is the decimal representation (17-digit round-trip safe)\n *   - B is the signed integer representing the full significand\n *         (i.e. (1 << 52) | mantissa, with sign applied)\n *   - C is the adjusted exponent (exponent - 1023 - 52)\n *\n * @param {string} input - any finite number as a string (NaN and ±Infinity return \"\")\n * @returns {string} the decomposed string\n */\nexport function decomposeFloat(input) {\n  const num = Number(input);\n  if (!Number.isFinite(num)) {\n    return \"\";\n  }\n  if (Object.is(num, 0)) {\n    return \"0 (0 × 2^0)\";\n  }\n  if (Object.is(num, -0)) {\n    return \"0 (-0 × 2^0)\";\n  }\n  \n  // A: the decimal representation with full precision\n  let A = num.toPrecision(17);\n  if (A.indexOf('.') !== -1) {\n    A = A.replace(/\\.?0+$/, '');\n  }\n  \n  // Get IEEE754 parts\n  const parts = decomposeIEEE754(num);\n  // If parts is empty, return empty string\n  if (!parts || !('sign' in parts && 'mantissa' in parts && 'exponent' in parts)) {\n    return \"\";\n  }\n  const { sign, mantissa, exponent } = parts;\n  // Convert sign bit to ±1 (0 becomes +1, 1 becomes -1)\n  const signValue = (sign === 0 ? 1n : -1n);\n  // The full significand (implicit 1 included)\n  const fullSignificand = (1n << 52n) | BigInt(mantissa);\n  // B: signed full significand\n  const B = signValue * fullSignificand;\n  // C: adjusted exponent: unbiased exponent minus 52\n  const C = BigInt(exponent - 1023) - 52n;\n  \n  return `${A} (${B.toString()} × 2^${C.toString()})`;\n}\n\nfunction decomposeIEEE754(value) {\n  if (!Number.isFinite(value)) {\n    return {};\n  }\n\n  const buffer = new ArrayBuffer(8);\n  const floatView = new Float64Array(buffer);\n  const byteView = new Uint8Array(buffer);\n\n  floatView[0] = value;\n\n  // Assemble the 64-bit binary representation\n  let bits = 0n;\n  for (let i = 7; i >= 0; i--) {\n    bits = (bits << 8n) | BigInt(byteView[i]);\n  }\n\n  const sign = Number((bits >> 63n) & 1n);\n  const exponentBits = (bits >> 52n) & 0x7FFn;\n  const mantissaBits = bits & 0xFFFFFFFFFFFFFn;\n\n  if (exponentBits === 0n) {\n    return {};\n  }\n\n  return {\n    sign,\n    mantissa: Number(mantissaBits),         // 52 bits\n    exponent: Number(exponentBits),         // still biased\n  };\n}","usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/stryker.config.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/test/generator/generator.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/test/toys/2024-10-02/hello.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/test/toys/2025-03-19/identity.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/test/toys/2025-03-21/booleanCoercer.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/test/toys/2025-03-21/italics.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/test/toys/2025-03-26/prettyFloat.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]