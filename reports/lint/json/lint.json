[{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/babel.config.cjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/copy-toys.js","messages":[{"ruleId":"complexity","severity":1,"message":"Function 'shouldCopy' has a complexity of 3. Maximum allowed is 2.","line":83,"column":1,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":85,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\n\n/**\n * This script copies toy JavaScript files from src/toys to public\n * It preserves the directory structure\n */\n\nimport fs from 'fs';\nimport path from 'path';\nimport { fileURLToPath } from 'url';\n\n// Get the directory name of the current module\nconst __dirname = path.dirname(fileURLToPath(import.meta.url));\n\n// Source and destination directories\nconst srcDir = path.join(__dirname, 'src', 'toys');\nconst destDir = path.join(__dirname, 'public');\n\n/**\n * Copy a file from source to destination\n * @param {string} src - Source file path\n * @param {string} dest - Destination file path\n */\nfunction copyFile(src, dest) {\n  // Create destination directory if it doesn't exist\n  const destDir = path.dirname(dest);\n  if (!fs.existsSync(destDir)) {\n    fs.mkdirSync(destDir, { recursive: true });\n  }\n  \n  // Copy the file\n  fs.copyFileSync(src, dest);\n  console.log(`Copied: ${src} -> ${dest}`);\n}\n\n/**\n * Recursively copy files from source to destination\n * @param {string} src - Source directory\n * @param {string} dest - Destination directory\n */\nfunction copyToyFiles(src, dest) {\n  const entries = fs.readdirSync(src, { withFileTypes: true });\n\n  for (const entry of entries) {\n    handleEntry(entry, src, dest);\n  }\n}\n\nfunction handleDirectoryEntry(entry, src, dest) {\n  const srcPath = path.join(src, entry.name);\n  copyToyFiles(srcPath, dest);\n}\n\nfunction handleFileEntry(entry, src, dest, srcPath) {\n  if (shouldCopy(entry)) {\n    const destPath = getDestPath(srcPath);\n    copyFile(srcPath, destPath);\n  }\n}\n\nfunction handleEntry(entry, src, dest) {\n  const srcPath = path.join(src, entry.name);\n\n  if (entry.isDirectory()) {\n    handleDirectoryEntry(entry, src, dest);\n  } else {\n    handleFileEntry(entry, src, dest, srcPath);\n  }\n}\n\nfunction isRegularFile(entry) {\n  return entry.isFile();\n}\n\nfunction isJavaScriptFile(entry) {\n  return entry.name.endsWith('.js');\n}\n\nfunction isTestFile(entry) {\n  return entry.name.endsWith('.test.js');\n}\n\nfunction shouldCopy(entry) {\n  return isRegularFile(entry) && isJavaScriptFile(entry) && !isTestFile(entry);\n}\n\nfunction getDestPath(srcPath) {\n  const relativePath = path.relative(srcDir, srcPath);\n  return path.join(destDir, relativePath);\n}\n\n// Execute the copy function\ncopyToyFiles(srcDir, destDir);\nconsole.log('Toy files copied successfully!');\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/eslint.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/generate.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/jest.config.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/src/generator/full-width.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/src/generator/generator.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/src/generator/head.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/src/generator/html.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/src/generator/interactive.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/src/generator/styles.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/src/generator/title.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/src/toys/2024-10-02/hello.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/src/toys/2025-03-19/identity.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/src/toys/2025-03-21/booleanCoercer.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/src/toys/2025-03-21/italics.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/src/toys/2025-03-26/prettyFloat.js","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'isInvalidNumber' is defined but never used.","line":26,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":26,"endColumn":25,"suggestions":[{"messageId":"removeVar","data":{"varName":"isInvalidNumber"},"fix":{"range":[598,674],"text":""},"desc":"Remove unused variable 'isInvalidNumber'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'parseValidNumber' is defined but never used.","line":34,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":34,"endColumn":26,"suggestions":[{"messageId":"removeVar","data":{"varName":"parseValidNumber"},"fix":{"range":[752,812],"text":""},"desc":"Remove unused variable 'parseValidNumber'."}]},{"ruleId":"complexity","severity":1,"message":"Function 'decomposeFloat' has a complexity of 4. Maximum allowed is 2.","line":43,"column":8,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":55,"endColumn":2}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"function isNonFinite(input) {\n  const num = Number(input);\n  return !Number.isFinite(num);\n}\n\nfunction getZeroVariantResult(num) {\n  const result = isZeroVariant(num);\n  return result !== null ? result : null;\n}\n\nfunction getValidNumber(input) {\n  if (isNonFinite(input)) return null;\n  return Number(input);\n}\n\nfunction getIEEEDecomposition(num) {\n  const parts = decomposeIEEE754(num);\n  if (!isValidIEEEParts(parts)) return null;\n  return getSignificandAndExponent(parts);\n}\n\nfunction formatFloatDecomposition(decimal, { B, C }) {\n  return `${decimal} (${B.toString()} × 2^${C.toString()})`;\n}\n\nfunction isInvalidNumber(input) {\n  return getValidNumber(input) === null;\n}\n\nfunction getZeroVariantString(num) {\n  return getZeroVariantResult(num);\n}\n\nfunction parseValidNumber(input) {\n  return Number(input);\n}\n\nfunction resolveZeroVariant(num) {\n  const zeroResult = getZeroVariantString(num);\n  return zeroResult ? zeroResult : null;\n}\n\nexport function decomposeFloat(input) {\n  const num = Number(input);\n  if (!Number.isFinite(num)) return \"\";\n\n  const zeroReturn = resolveZeroVariant(num);\n  if (zeroReturn) return zeroReturn;\n\n  const A = formatDecimal(num);\n  const decomposition = getIEEEDecomposition(num);\n  if (!decomposition) return \"\";\n\n  return formatFloatDecomposition(A, decomposition);\n}\n\nfunction isPositiveZero(n) {\n  return Object.is(n, 0);\n}\n\nfunction isNegativeZero(n) {\n  return Object.is(n, -0);\n}\n\nfunction isPositiveZeroResult(num) {\n  return isPositiveZero(num) ? \"0 (0 × 2^0)\" : null;\n}\n\nfunction isNegativeZeroResult(num) {\n  return isNegativeZero(num) ? \"0 (-0 × 2^0)\" : null;\n}\n\nfunction isZeroVariant(num) {\n  return isPositiveZeroResult(num) || isNegativeZeroResult(num);\n}\n\nfunction formatDecimal(num) {\n  let A = num.toPrecision(17);\n  return A.includes('.') ? A.replace(/\\.?0+$/, '') : A;\n}\n\nfunction hasIEEEFields(parts) {\n  return ['sign', 'mantissa', 'exponent'].every(key => key in parts);\n}\n\nfunction isValidIEEEParts(parts) {\n  return Boolean(parts) && hasIEEEFields(parts);\n}\n\nfunction getSignificandAndExponent({ sign, mantissa, exponent }) {\n  const signValue = sign === 0 ? 1n : -1n;\n  const fullSignificand = (1n << 52n) | BigInt(mantissa);\n  const B = signValue * fullSignificand;\n  const C = BigInt(exponent - 1023) - 52n;\n  return { B, C };\n}\n\nfunction decomposeIEEE754(value) {\n  if (!Number.isFinite(value)) return {};\n\n  const bits = getFloat64Bits(value);\n  return extractIEEEComponents(bits);\n}\n\nfunction getFloat64Bits(value) {\n  const buffer = new ArrayBuffer(8);\n  const floatView = new Float64Array(buffer);\n  const byteView = new Uint8Array(buffer);\n\n  floatView[0] = value;\n\n  let bits = 0n;\n  for (let i = 7; i >= 0; i--) {\n    bits = (bits << 8n) | BigInt(byteView[i]);\n  }\n\n  return bits;\n}\n\nfunction extractIEEEComponents(bits) {\n  const sign = Number((bits >> 63n) & 1n);\n  const exponentBits = (bits >> 52n) & 0x7FFn;\n  const mantissaBits = bits & 0xFFFFFFFFFFFFFn;\n\n  if (exponentBits === 0n) {\n    return {};\n  }\n\n  return {\n    sign,\n    mantissa: Number(mantissaBits),\n    exponent: Number(exponentBits),\n  };\n}","usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/src/toys/2025-03-28/rand.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/src/toys/2025-03-29/fishingGame.js","messages":[{"ruleId":"complexity","severity":1,"message":"Function 'getBaitData' has a complexity of 3. Maximum allowed is 2.","line":24,"column":1,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":33,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"function isRecognizedBait(baitKey, baitOptions) {\n  return baitKey in baitOptions;\n}\n\nfunction isEmptyBait(baitKey) {\n  return baitKey.length === 0;\n}\n\nfunction getDefaultBaitResponse(moodDescription) {\n  return {\n    isError: true,\n    message: `You cast your line with nothing but hesitation. Without any bait, the waters remain undisturbed in their ${moodDescription}.`\n  };\n}\n\nfunction getRecognizedBait(baitKey, baitOptions) {\n  return baitOptions[baitKey];\n}\n\nfunction getUnrecognizedBait() {\n  return { modifier: 0, description: \"an unconventional bait\" };\n}\n\nfunction getBaitData(input, baitOptions, moodDescription) {\n  const baitKey = input.trim().toLowerCase();\n  if (isRecognizedBait(baitKey, baitOptions)) {\n    return getRecognizedBait(baitKey, baitOptions);\n  }\n  if (isEmptyBait(baitKey)) {\n    return getDefaultBaitResponse(moodDescription);\n  }\n  return getUnrecognizedBait();\n}\n\nfunction getTimeOfDay(hour) {\n  const ranges = [\n    { start: 5, end: 12, label: \"morning\" },\n    { start: 12, end: 17, label: \"afternoon\" },\n    { start: 17, end: 21, label: \"evening\" },\n    { start: 21, end: 24, label: \"night\" },\n    { start: 0, end: 5, label: \"night\" },\n  ];\n  const match = ranges.find(({ start, end }) => hour >= start && hour < end);\n  if (!match) throw new Error(`Unrecognized hour: ${hour}`);\n  return match.label;\n}\n\nfunction getSeason(month) {\n  const ranges = [\n    { months: [11, 0, 1], label: \"winter\" },\n    { months: [2, 3, 4], label: \"spring\" },\n    { months: [5, 6, 7], label: \"summer\" },\n    { months: [8, 9, 10], label: \"fall\" },\n  ];\n  const match = ranges.find(({ months }) => months.includes(month));\n  if (!match) throw new Error(`Unrecognized month: ${month}`);\n  return match.label;\n}\n\nfunction getMoodDescription(season, timeOfDay) {\n  const seasonDescriptions = {\n    winter: \"crisp, icy waters\",\n    spring: \"bubbling, fresh currents\",\n    summer: \"warm, shimmering waves\",\n    fall: \"cool, reflective ponds\",\n  };\n  const timeDescriptions = {\n    morning: \"as dawn breaks with promise\",\n    afternoon: \"under a vibrant sun\",\n    evening: \"in the glow of twilight\",\n    night: \"beneath a silent, starry sky\",\n  };\n  return `${seasonDescriptions[season]} ${timeDescriptions[timeOfDay]}`;\n}\n\nfunction isSilentCatch(chance) {\n  return chance < 0.3;\n}\n\nfunction isCommonCatch(chance) {\n  return chance < 0.6;\n}\n\nfunction isTroutCatch(chance) {\n  return chance < 0.85;\n}\n\nconst fishingOutcomes = [\n  {\n    check: isSilentCatch,\n    describe: (bait, mood) =>\n      `the water stays silent. Despite your use of ${bait}, no fish disturb the ${mood}.`,\n  },\n  {\n    check: isCommonCatch,\n    describe: (bait, mood) =>\n      `a common carp surfaces gently, a modest reward for your effort with ${bait}, set against ${mood}.`,\n  },\n  {\n    check: isTroutCatch,\n    describe: (bait, mood) =>\n      `a glimmering trout appears briefly, its shimmer echoing the beauty of ${mood}. Your choice of ${bait} worked well.`,\n  },\n  {\n    check: () => true,\n    describe: (bait, mood) =>\n      `in a burst of brilliance, a legendary golden fish leaps forth—its radiance matching the splendor of ${mood}. Your ${bait} has yielded a prize.`,\n  },\n];\n\nfunction getFishingOutcome(effectiveChance, baitDescription, moodDescription) {\n  return fishingOutcomes.find(({ check }) => check(effectiveChance)).describe(baitDescription, moodDescription);\n}\n\nfunction getBaitOptions() {\n  return {\n    \"worm\": { modifier: 0.0, description: \"a wriggling worm\" },\n    \"insect\": { modifier: 0.05, description: \"a lively insect\" },\n    \"bread\": { modifier: -0.05, description: \"a slice of bread\" },\n    \"cheese\": { modifier: 0.1, description: \"a pungent piece of cheese\" },\n    \"shiny bait\": { modifier: 0.15, description: \"a glittering lure\" },\n    \"doughnut\": { modifier: 0.2, description: \"a tempting doughnut\" },\n    \"grub\": { modifier: 0.05, description: \"a succulent grub\" },\n    \"minnow\": { modifier: 0.1, description: \"a darting minnow\" },\n    \"sausage\": { modifier: 0.2, description: \"a savory sausage\" },\n    \"maggot\": { modifier: -0.1, description: \"a squirming maggot\" },\n  };\n}\n\nfunction getTimeContext(getCurrentTime) {\n  const date = new Date(getCurrentTime());\n  const month = date.getMonth();\n  const hour = date.getHours();\n  const season = getSeason(month);\n  const timeOfDay = getTimeOfDay(hour);\n  return { season, timeOfDay };\n}\n\nfunction fishingGame(input, env) {\n  const { season, timeOfDay } = getTimeContext(env.get(\"getCurrentTime\"));\n\n  const moodDescription = getMoodDescription(season, timeOfDay);\n\n  const baitOptions = getBaitOptions();\n\n  const baitDataOrError = getBaitData(input, baitOptions, moodDescription);\n  if (baitDataOrError.isError) return baitDataOrError.message;\n  const baitData = baitDataOrError;\n\n  const getRandomNumber = env.get(\"getRandomNumber\");\n  const baseChance = getRandomNumber();\n  const effectiveChance = Math.min(1, Math.max(0, baseChance + baitData.modifier));\n\n  const outcome = getFishingOutcome(effectiveChance, baitData.description, moodDescription);\n\n  return `Casting your line with ${baitData.description}, you await a catch. ${outcome}`;\n}\n\nexport { fishingGame };","usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/src/toys/2025-03-29/get.js","messages":[{"ruleId":"complexity","severity":1,"message":"Function 'get' has a complexity of 10. Maximum allowed is 2.","line":7,"column":8,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":38,"endColumn":2}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Retrieves a value from data provided by the environment using the input as a key.\n * @param {string} input - The key to look up in the data.\n * @param {Map<string, Function>} env - Environment map containing dependencies. Expected: 'getData'.\n * @returns {string} The JSON stringified value associated with the key, or an error message.\n */\nexport function get(input, env) {\n  if (!env || typeof env.get !== 'function') {\n    return \"Error: 'env' Map with 'get' method is required.\";\n  }\n  const getData = env.get('getData');\n  if (typeof getData !== 'function') {\n    return \"Error: 'getData' function not found in env.\";\n  }\n\n  try {\n    const data = getData();\n    // Ensure data is an object (and not null) before trying to access keys\n    if (data === null || typeof data !== 'object' || Array.isArray(data)) {\n        return \"Error: 'getData' did not return a valid plain object.\";\n    }\n    if (Object.prototype.hasOwnProperty.call(data, input)) {\n      // Return a string representation for display purposes\n      const value = data[input];\n      // Handle potential circular structures in JSON.stringify\n      try {\n        return JSON.stringify(value);\n      } catch (stringifyError) {\n          return `Error stringifying value for key \"${input}\": ${stringifyError.message}`;\n      }\n    } else {\n      return `Error: Key \"${input}\" not found in data. Available keys: ${Object.keys(data).join(', ')}`;\n    }\n  } catch (error) {\n      // Catch errors from getData() execution or other unexpected issues\n      return `Error calling getData or accessing data: ${error.message}`;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/stryker.config.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/test/generator/generator.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/test/toys/2024-10-02/hello.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/test/toys/2025-03-19/identity.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/test/toys/2025-03-21/booleanCoercer.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/test/toys/2025-03-21/italics.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/test/toys/2025-03-26/prettyFloat.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/test/toys/2025-03-28/rand.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/test/toys/2025-03-29/fishingGame.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/matthew.heard/Code/Matt/dadeto/test/toys/2025-03-29/get.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]