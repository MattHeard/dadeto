<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Dadeto Writer</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500&family=Instrument+Serif:ital@0;1&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        --bg: #f3efe3;
        --bg-accent: #e2d5bb;
        --panel: rgba(255, 252, 245, 0.92);
        --panel-muted: rgba(244, 236, 220, 0.88);
        --ink: #1d261f;
        --muted: #5d665f;
        --line: rgba(29, 38, 31, 0.14);
        --strong-line: rgba(29, 38, 31, 0.28);
        --accent: #a03c2f;
        --accent-soft: rgba(160, 60, 47, 0.14);
        --success: #2d6a4f;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        height: 100vh;
        overflow: hidden;
        color: var(--ink);
        font-family: 'IBM Plex Mono', monospace;
        background:
          radial-gradient(circle at top left, rgba(160, 60, 47, 0.16), transparent 28rem),
          linear-gradient(135deg, var(--bg), #efe6d2 56%, var(--bg-accent));
      }

      html {
        height: 100vh;
        overflow: hidden;
      }

      .shell {
        width: min(1400px, calc(100vw - 2rem));
        margin: 1rem auto;
        height: calc(100vh - 2rem);
        display: grid;
        grid-template-rows: auto minmax(0, 1fr);
        gap: 1rem;
      }

      .masthead,
      .workflow-panel {
        border: 1px solid var(--strong-line);
        background: var(--panel);
        backdrop-filter: blur(10px);
        box-shadow: 0 18px 48px rgba(29, 38, 31, 0.08);
      }

      .masthead {
        padding: 1.25rem 1.25rem 1rem;
      }

      h1,
      h2 {
        margin: 0;
        font-family: 'Instrument Serif', serif;
        font-weight: 400;
        letter-spacing: 0.02em;
      }

      h1 {
        font-size: clamp(2.3rem, 6vw, 4.7rem);
        line-height: 0.92;
      }

      h2 {
        font-size: clamp(1.45rem, 3vw, 2.2rem);
        line-height: 1;
      }

      .subhead {
        margin: 0.75rem 0 0;
        max-width: 52rem;
        color: var(--muted);
        line-height: 1.5;
      }

      .status-row {
        margin-top: 1rem;
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
        align-items: center;
        color: var(--muted);
        font-size: 0.95rem;
      }

      .pill {
        padding: 0.35rem 0.6rem;
        border: 1px solid var(--line);
        background: rgba(255, 255, 255, 0.55);
      }

      .button-row {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
        margin-top: 1rem;
      }

      button {
        border: 1px solid var(--strong-line);
        background: rgba(255, 255, 255, 0.66);
        color: var(--ink);
        padding: 0.55rem 0.85rem;
        font: 500 0.95rem/1 'IBM Plex Mono', monospace;
        cursor: pointer;
      }

      button:hover {
        background: rgba(255, 255, 255, 0.92);
      }

      .save-state.saving {
        color: var(--accent);
      }

      .save-state.saved {
        color: var(--success);
      }

      .sequence {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        margin-top: 1rem;
      }

      .sequence-step {
        border: 1px solid var(--line);
        padding: 0.4rem 0.65rem;
        background: rgba(255, 255, 255, 0.5);
        color: var(--muted);
        cursor: pointer;
      }

      .sequence-step.active {
        border-color: var(--accent);
        color: var(--accent);
        background: rgba(160, 60, 47, 0.08);
      }

      .sequence-step.visible-secondary {
        border-color: rgba(160, 60, 47, 0.4);
        color: var(--ink);
        background: rgba(160, 60, 47, 0.04);
      }

      .workspace {
        display: grid;
        grid-template-columns: minmax(0, 1fr) minmax(0, 1fr);
        min-height: 0;
        gap: 1rem;
      }

      .workflow-panel {
        overflow: hidden;
        min-height: 0;
        height: 100%;
        display: grid;
        grid-template-rows: auto minmax(0, 1fr);
      }

      .panel-header {
        display: flex;
        justify-content: space-between;
        gap: 1rem;
        align-items: baseline;
        padding: 1rem 1.25rem;
        border-bottom: 1px solid var(--line);
      }

      .panel-header.previous {
        background: var(--panel-muted);
      }

      .panel-meta {
        color: var(--muted);
        font-size: 0.9rem;
      }

      .panel-body {
        display: block;
        width: 100%;
        min-height: 0;
        height: 100%;
        border: 0;
        padding: 1.25rem;
        background:
          linear-gradient(transparent 0, transparent calc(1.7rem - 1px), rgba(29, 38, 31, 0.06) calc(1.7rem - 1px), rgba(29, 38, 31, 0.06) 1.7rem);
        background-size: 100% 1.7rem;
        color: var(--ink);
        font: 500 1rem/1.7 'IBM Plex Mono', monospace;
        white-space: pre-wrap;
        overflow: auto;
      }

      .panel-body.readonly {
        border: 0;
      }

      .panel-body.readonly:focus {
        outline: none;
      }

      .intro-emoji {
        display: block;
        font-size: 2.2rem;
        margin-bottom: 0.5rem;
      }

      textarea.panel-body {
        resize: none;
        caret-color: var(--accent);
        white-space: pre-wrap;
      }

      textarea.panel-body:focus {
        outline: none;
        box-shadow: inset 0 0 0 2px var(--accent-soft);
      }

      @media (max-width: 900px) {
        .workspace {
          grid-template-columns: minmax(0, 1fr);
        }
      }

      @media (max-width: 720px) {
        .shell {
          width: min(100vw, calc(100vw - 1rem));
          margin: 0.5rem auto;
        }

        .masthead,
        .panel-header,
        .panel-body {
          padding: 1rem;
        }
      }
    </style>
  </head>
  <body>
    <main class="shell">
      <section class="masthead">
        <h1 id="masthead-title">Untitled Post</h1>
        <p class="subhead">
          Write forward through a sequence: thesis, syllogistic argument,
          outline, then numbered drafts. Use <strong>Alt+Left</strong> and
          <strong>Alt+Right</strong> to page through adjacent documents.
        </p>
        <div class="status-row">
          <span class="pill" id="storage-mode">Storage: server</span>
          <span class="pill" id="document-path">Loading documentâ€¦</span>
          <span class="save-state" id="save-state">Loadingâ€¦</span>
        </div>
        <div class="button-row">
          <button id="pick-directory" type="button">Pick Blog Directory</button>
          <button id="use-server-storage" type="button">Use Server Storage</button>
        </div>
        <div class="sequence" id="sequence"></div>
      </section>
      <section class="workspace">
        <article class="workflow-panel">
          <header class="panel-header previous">
            <div>
              <div class="panel-meta">Earlier document</div>
              <h2 id="previous-title">Loadingâ€¦</h2>
            </div>
          </header>
          <div
            class="panel-body readonly"
            id="previous-content"
            aria-label="Earlier markdown document"
          ></div>
        </article>
        <article class="workflow-panel">
          <header class="panel-header">
            <div>
              <div class="panel-meta">Current document</div>
              <h2 id="current-title">Loadingâ€¦</h2>
            </div>
          </header>
          <textarea
            class="panel-body"
            id="current-content"
            spellcheck="false"
            placeholder="# Start writing"
            aria-label="Current markdown document"
          ></textarea>
        </article>
      </section>
    </main>
    <script type="module">
      const documentPath = document.getElementById('document-path');
      const storageMode = document.getElementById('storage-mode');
      const saveState = document.getElementById('save-state');
      const sequence = document.getElementById('sequence');
      const pickDirectoryButton = document.getElementById('pick-directory');
      const useServerStorageButton = document.getElementById('use-server-storage');
      const previousTitle = document.getElementById('previous-title');
      const previousContent = document.getElementById('previous-content');
      const currentTitle = document.getElementById('current-title');
      const currentContent = document.getElementById('current-content');
      const mastheadTitle = document.getElementById('masthead-title');

      const DEFAULT_SEQUENCE = [
        { id: 'thesis', title: 'Thesis' },
        { id: 'syllogistic-argument', title: 'Syllogistic Argument' },
        { id: 'outline', title: 'Outline' },
        { id: 'draft-1', title: 'Draft 1' },
      ];

      const INTRO_MESSAGES = [
        { emoji: 'ðŸŒž', greeting: 'Good morning. The thesis is ready when you are.' },
        { emoji: 'ðŸª´', greeting: 'Small steps compound. Start with the core claim.' },
        { emoji: 'âš”ï¸', greeting: 'Sharpen the premise before you swing at the draft.' },
        { emoji: 'ðŸ§­', greeting: 'Orientation first. Then argument.' },
        { emoji: 'ðŸ”¥', greeting: 'Write the dangerous sentence first.' },
        { emoji: 'ðŸŒŠ', greeting: 'Stay calm. Make the next paragraph inevitable.' },
      ];

      const state = {
        workflow: null,
        lastSavedValues: {},
        isLoaded: false,
        storage: null,
      };

      const setSaveState = (message, className = '') => {
        saveState.textContent = message;
        saveState.className = `save-state ${className}`.trim();
      };

      const cloneStep = step => ({
        id: step.id,
        title: step.title,
      });

      const isDraftId = id => /^draft-\d+$/.test(id);

      const extractLevelOneHeading = content => {
        const match = content.match(/^# (.+)$/m);
        return match ? match[1].trim() : '';
      };

      const getWorkflowHeading = workflow =>
        workflow?.heading?.trim() || 'Untitled Post';

      const getPrefilledDocumentContent = workflowDocument => {
        if (!workflowDocument) {
          return '';
        }

        if (workflowDocument.content.trim()) {
          return workflowDocument.content;
        }

        const heading = state.workflow?.heading?.trim();
        return heading ? `# ${heading}\n\n` : '';
      };

      const createServerStorage = () => ({
        label: 'server',
        async loadWorkflow() {
          const response = await fetch('/api/writer/workflow');
          if (!response.ok) {
            throw new Error('Failed to load workflow');
          }
          return response.json();
        },
        async saveDocument(documentId, content) {
          const response = await fetch(`/api/writer/document/${documentId}`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ content }),
          });

          if (!response.ok) {
            throw new Error('Failed to save document');
          }

          return response.json();
        },
        async moveWorkflow(direction) {
          const response = await fetch('/api/writer/workflow/move', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ direction }),
          });

          if (!response.ok) {
            throw new Error('Failed to move workflow');
          }

          return response.json();
        },
        async setActiveIndex(activeIndex) {
          const response = await fetch('/api/writer/workflow/select', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ activeIndex }),
          });

          if (!response.ok) {
            throw new Error('Failed to select document');
          }

          return response.json();
        },
      });

      const readFileText = async handle => {
        const file = await handle.getFile();
        return file.text();
      };

      const writeFileText = async (handle, content) => {
        const writable = await handle.createWritable();
        await writable.write(content);
        await writable.close();
      };

      const createDirectoryStorage = async directoryHandle => {
        const workflowFileHandle = await directoryHandle.getFileHandle('workflow.json', {
          create: true,
        });
        const documentsDirHandle = await directoryHandle.getDirectoryHandle('documents', {
          create: true,
        });

        const ensureDocumentFile = step =>
          documentsDirHandle.getFileHandle(`${step.id}.md`, { create: true });
        const getDocumentFileName = step => `${step.id}.md`;

        const readWorkflowDefinition = async () => {
          const rawWorkflow = await readFileText(workflowFileHandle);
          if (!rawWorkflow.trim()) {
            return null;
          }

          const parsedWorkflow = JSON.parse(rawWorkflow);
          const steps = Array.isArray(parsedWorkflow?.steps) && parsedWorkflow.steps.length > 0
            ? parsedWorkflow.steps.map(cloneStep)
            : DEFAULT_SEQUENCE.map(cloneStep);
          const maxIndex = Math.max(0, steps.length - 1);
          const activeIndex = Number.isInteger(parsedWorkflow?.activeIndex)
            ? Math.min(Math.max(parsedWorkflow.activeIndex, 0), maxIndex)
            : Math.min(1, maxIndex);

          return {
            steps,
            activeIndex,
            heading:
              typeof parsedWorkflow?.heading === 'string'
                ? parsedWorkflow.heading.trim()
                : '',
          };
        };

        const writeWorkflowDefinition = workflow =>
          writeFileText(workflowFileHandle, JSON.stringify(workflow, null, 2));

        const deleteDocumentFile = async step => {
          await documentsDirHandle.removeEntry(getDocumentFileName(step));
        };

        const pruneEmptyTrailingDrafts = async workflow => {
          while (
            workflow.steps.length > DEFAULT_SEQUENCE.length &&
            workflow.steps.length - 1 > workflow.activeIndex
          ) {
            const lastStep = workflow.steps.at(-1);
            if (!lastStep || !isDraftId(lastStep.id)) {
              break;
            }

            const handle = await ensureDocumentFile(lastStep);
            const content = await readFileText(handle);
            if (content.trim()) {
              break;
            }

            await deleteDocumentFile(lastStep);
            workflow.steps.pop();
          }

          const draftSteps = workflow.steps.filter(step => isDraftId(step.id));
          draftSteps.forEach((step, index) => {
            const nextNumber = index + 1;
            step.id = `draft-${nextNumber}`;
            step.title = `Draft ${nextNumber}`;
          });

          workflow.activeIndex = Math.min(
            workflow.activeIndex,
            Math.max(0, workflow.steps.length - 1)
          );
        };

        const ensureWorkflowDefinition = async () => {
          const existingWorkflow = await readWorkflowDefinition();
          if (existingWorkflow) {
            await pruneEmptyTrailingDrafts(existingWorkflow);
            await writeWorkflowDefinition(existingWorkflow);
            return existingWorkflow;
          }

          const workflow = {
            steps: DEFAULT_SEQUENCE.map(cloneStep),
            activeIndex: 1,
            heading: '',
          };

          await Promise.all(
            workflow.steps.map(async step => {
              const handle = await ensureDocumentFile(step);
              const existingContent = await readFileText(handle);
              if (!existingContent) {
                await writeFileText(handle, '');
              }
            })
          );
          await writeWorkflowDefinition(workflow);

          return workflow;
        };

        const serializeWorkflow = async workflow => {
          const documents = await Promise.all(
            workflow.steps.map(async step => {
              const handle = await ensureDocumentFile(step);
              return {
                id: step.id,
                title: step.title,
                path: `${directoryHandle.name}/documents/${step.id}.md`,
                content: await readFileText(handle),
              };
            })
          );

        return {
          workflowPath: `${directoryHandle.name}/workflow.json`,
            activeIndex: workflow.activeIndex,
            heading: workflow.heading ?? '',
            documents,
          };
        };

        return {
          label: `directory:${directoryHandle.name}`,
          async loadWorkflow() {
            return serializeWorkflow(await ensureWorkflowDefinition());
          },
          async saveDocument(documentId, content) {
            const workflow = await ensureWorkflowDefinition();
            const step = workflow.steps.find(candidate => candidate.id === documentId);

            if (!step) {
              throw new Error(`Unknown document id: ${documentId}`);
            }

            const nextHeading = extractLevelOneHeading(content);
            if (nextHeading) {
              workflow.heading = nextHeading;
            }

            const handle = await ensureDocumentFile(step);
            if (content.trim()) {
              await writeFileText(handle, content);
            } else {
              await deleteDocumentFile(step).catch(error => {
                if (error?.name !== 'NotFoundError') {
                  throw error;
                }
              });
            }
            await pruneEmptyTrailingDrafts(workflow);
            await writeWorkflowDefinition(workflow);

            return {
              documentId,
              path: `${directoryHandle.name}/documents/${documentId}.md`,
              savedAt: new Date().toISOString(),
            };
          },
          async moveWorkflow(direction) {
            const workflow = await ensureWorkflowDefinition();
            let nextIndex = workflow.activeIndex + (direction === 'left' ? -1 : 1);

            if (direction === 'right' && workflow.activeIndex === workflow.steps.length - 1) {
              const lastStep = workflow.steps.at(-1);
              if (lastStep && isDraftId(lastStep.id)) {
                const nextDraftNumber =
                  workflow.steps.filter(step => isDraftId(step.id)).length + 1;
                const nextStep = {
                  id: `draft-${nextDraftNumber}`,
                  title: `Draft ${nextDraftNumber}`,
                };
                workflow.steps.push(nextStep);
                const nextHandle = await ensureDocumentFile(nextStep);
                const existingContent = await readFileText(nextHandle);
                if (!existingContent) {
                  await writeFileText(nextHandle, '');
                }
              }
            }

            nextIndex = Math.min(
              Math.max(nextIndex, 0),
              Math.max(0, workflow.steps.length - 1)
            );
            workflow.activeIndex = nextIndex;
            await pruneEmptyTrailingDrafts(workflow);
            await writeWorkflowDefinition(workflow);
            return serializeWorkflow(workflow);
          },
          async setActiveIndex(activeIndex) {
            const workflow = await ensureWorkflowDefinition();
            workflow.activeIndex = Math.min(
              Math.max(activeIndex, 0),
              Math.max(0, workflow.steps.length - 1)
            );
            await pruneEmptyTrailingDrafts(workflow);
            await writeWorkflowDefinition(workflow);
            return serializeWorkflow(workflow);
          },
        };
      };

      const getCurrentDocument = () =>
        state.workflow?.documents?.[state.workflow.activeIndex] ?? null;

      const getPreviousDocument = () =>
        state.workflow?.documents?.[state.workflow.activeIndex - 1] ?? null;

      const getIntroMessage = () => {
        const sourceIndex = state.workflow?.activeIndex ?? 0;
        return INTRO_MESSAGES[sourceIndex % INTRO_MESSAGES.length];
      };

      const renderSequence = () => {
        sequence.replaceChildren();
        state.workflow.documents.forEach((workflowDocument, index) => {
          const isFutureDocument = index > state.workflow.activeIndex;
          const isEmptyFutureDocument =
            isFutureDocument && !(workflowDocument.content ?? '').trim();

          if (isEmptyFutureDocument) {
            return;
          }

          const step = document.createElement('span');
          step.textContent = `${index + 1}. ${workflowDocument.title}`;
          const isCurrent = index === state.workflow.activeIndex;
          const isPrevious = index === state.workflow.activeIndex - 1;

          step.className = 'sequence-step';
          if (isCurrent) {
            step.classList.add('active');
          } else if (isPrevious) {
            step.classList.add('visible-secondary');
          }
          step.addEventListener('click', () => {
            selectWorkflowIndex(index).catch(error => {
              setSaveState(error.message, 'saving');
            });
          });
          sequence.appendChild(step);
        });
      };

      const renderWorkflow = () => {
        const previousDocument = getPreviousDocument();
        const currentDocument = getCurrentDocument();
        const introMessage = getIntroMessage();
        const currentValue = getPrefilledDocumentContent(currentDocument);

        storageMode.textContent = `Storage: ${state.storage?.label ?? 'server'}`;
        documentPath.textContent = currentDocument?.path ?? 'No document';
        mastheadTitle.textContent = getWorkflowHeading(state.workflow);
        document.title = getWorkflowHeading(state.workflow);
        previousTitle.textContent =
          previousDocument?.title ?? `${introMessage.emoji} Warm-up`;
        previousContent.replaceChildren();
        if (previousDocument) {
          previousContent.textContent = previousDocument.content;
        } else {
          const emoji = document.createElement('span');
          emoji.className = 'intro-emoji';
          emoji.textContent = introMessage.emoji;
          previousContent.append(emoji, introMessage.greeting);
        }
        currentTitle.textContent = currentDocument?.title ?? 'No current document';
        currentContent.value = currentValue;
        state.lastSavedValues = Object.fromEntries(
          state.workflow.documents.map(document => [document.id, document.content])
        );
        renderSequence();
      };

      const loadWorkflow = async () => {
        state.workflow = await state.storage.loadWorkflow();
        state.isLoaded = true;
        renderWorkflow();
        setSaveState('Loaded', 'saved');
      };

      const saveVisibleDocument = async (documentRecord, nextValue) => {
        if (
          !state.isLoaded ||
          !documentRecord ||
          nextValue === state.lastSavedValues[documentRecord.id]
        ) {
          return;
        }

        setSaveState('Savingâ€¦', 'saving');

        const payload = await state.storage.saveDocument(documentRecord.id, nextValue);
        documentRecord.content = nextValue;
        state.lastSavedValues[documentRecord.id] = nextValue;
        const nextHeading = extractLevelOneHeading(nextValue);
        if (nextHeading) {
          state.workflow.heading = nextHeading;
          mastheadTitle.textContent = nextHeading;
          document.title = nextHeading;
        }
        if (getCurrentDocument()?.id === documentRecord.id) {
          documentPath.textContent = payload.path;
        }
        setSaveState(
          `Saved ${new Date(payload.savedAt).toLocaleTimeString()}`,
          'saved'
        );
      };

      const saveDocument = async () => {
        await saveVisibleDocument(getCurrentDocument(), currentContent.value);
      };

      const moveWorkflow = async direction => {
        await saveDocument();

        state.workflow = await state.storage.moveWorkflow(direction);
        renderWorkflow();
        setSaveState(`Moved ${direction}`, 'saved');
      };

      const selectWorkflowIndex = async nextIndex => {
        await saveDocument();
        state.workflow = await state.storage.setActiveIndex(nextIndex);
        renderWorkflow();
        setSaveState(`Selected ${state.workflow.documents[nextIndex]?.title ?? 'document'}`, 'saved');
      };

      const switchStorage = async nextStorage => {
        await saveDocument();
        state.storage = nextStorage;
        state.workflow = null;
        state.isLoaded = false;
        mastheadTitle.textContent = 'Loadingâ€¦';
        document.title = 'Loadingâ€¦';
        documentPath.textContent = 'Loading documentâ€¦';
        storageMode.textContent = `Storage: ${state.storage?.label ?? 'server'}`;
        await loadWorkflow();
      };

      pickDirectoryButton.addEventListener('click', () => {
        if (typeof window.showDirectoryPicker !== 'function') {
          setSaveState('Directory picker is not supported in this browser', 'saving');
          return;
        }

        window
          .showDirectoryPicker({ mode: 'readwrite' })
          .then(createDirectoryStorage)
          .then(switchStorage)
          .then(() => {
            setSaveState('Directory connected', 'saved');
          })
          .catch(error => {
            if (error?.name === 'AbortError') {
              return;
            }
            setSaveState(error.message, 'saving');
          });
      });

      useServerStorageButton.addEventListener('click', () => {
        switchStorage(createServerStorage()).catch(error => {
          setSaveState(error.message, 'saving');
        });
      });

      window.addEventListener('keydown', event => {
        if (!event.altKey) {
          return;
        }

        if (event.key === 'ArrowLeft') {
          event.preventDefault();
          moveWorkflow('left').catch(error => {
            setSaveState(error.message, 'saving');
          });
        }

        if (event.key === 'ArrowRight') {
          event.preventDefault();
          moveWorkflow('right').catch(error => {
            setSaveState(error.message, 'saving');
          });
        }
      });

      state.storage = createServerStorage();
      loadWorkflow().catch(error => {
        setSaveState(error.message, 'saving');
      });

      window.setInterval(() => {
        saveDocument().catch(error => {
          setSaveState(error.message, 'saving');
        });
      }, 1000);
    </script>
  </body>
</html>
